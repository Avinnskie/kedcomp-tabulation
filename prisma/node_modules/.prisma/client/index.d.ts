
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Participant
 * 
 */
export type Participant = $Result.DefaultSelection<Prisma.$ParticipantPayload>
/**
 * Model Judge
 * 
 */
export type Judge = $Result.DefaultSelection<Prisma.$JudgePayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Round
 * 
 */
export type Round = $Result.DefaultSelection<Prisma.$RoundPayload>
/**
 * Model RoundAssignment
 * 
 */
export type RoundAssignment = $Result.DefaultSelection<Prisma.$RoundAssignmentPayload>
/**
 * Model Score
 * 
 */
export type Score = $Result.DefaultSelection<Prisma.$ScorePayload>
/**
 * Model MatchResult
 * 
 */
export type MatchResult = $Result.DefaultSelection<Prisma.$MatchResultPayload>
/**
 * Model TeamAssignment
 * 
 */
export type TeamAssignment = $Result.DefaultSelection<Prisma.$TeamAssignmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DebatePosition: {
  OG: 'OG',
  OO: 'OO',
  CG: 'CG',
  CO: 'CO'
};

export type DebatePosition = (typeof DebatePosition)[keyof typeof DebatePosition]


export const ScoreType: {
  TEAM: 'TEAM',
  INDIVIDUAL: 'INDIVIDUAL'
};

export type ScoreType = (typeof ScoreType)[keyof typeof ScoreType]

}

export type DebatePosition = $Enums.DebatePosition

export const DebatePosition: typeof $Enums.DebatePosition

export type ScoreType = $Enums.ScoreType

export const ScoreType: typeof $Enums.ScoreType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Teams
 * const teams = await prisma.team.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Teams
   * const teams = await prisma.team.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.participant`: Exposes CRUD operations for the **Participant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participants
    * const participants = await prisma.participant.findMany()
    * ```
    */
  get participant(): Prisma.ParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.judge`: Exposes CRUD operations for the **Judge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Judges
    * const judges = await prisma.judge.findMany()
    * ```
    */
  get judge(): Prisma.JudgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.round`: Exposes CRUD operations for the **Round** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rounds
    * const rounds = await prisma.round.findMany()
    * ```
    */
  get round(): Prisma.RoundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roundAssignment`: Exposes CRUD operations for the **RoundAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoundAssignments
    * const roundAssignments = await prisma.roundAssignment.findMany()
    * ```
    */
  get roundAssignment(): Prisma.RoundAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.score`: Exposes CRUD operations for the **Score** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scores
    * const scores = await prisma.score.findMany()
    * ```
    */
  get score(): Prisma.ScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchResult`: Exposes CRUD operations for the **MatchResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchResults
    * const matchResults = await prisma.matchResult.findMany()
    * ```
    */
  get matchResult(): Prisma.MatchResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamAssignment`: Exposes CRUD operations for the **TeamAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamAssignments
    * const teamAssignments = await prisma.teamAssignment.findMany()
    * ```
    */
  get teamAssignment(): Prisma.TeamAssignmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Team: 'Team',
    Participant: 'Participant',
    Judge: 'Judge',
    Room: 'Room',
    Round: 'Round',
    RoundAssignment: 'RoundAssignment',
    Score: 'Score',
    MatchResult: 'MatchResult',
    TeamAssignment: 'TeamAssignment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "team" | "participant" | "judge" | "room" | "round" | "roundAssignment" | "score" | "matchResult" | "teamAssignment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Participant: {
        payload: Prisma.$ParticipantPayload<ExtArgs>
        fields: Prisma.ParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findFirst: {
            args: Prisma.ParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          findMany: {
            args: Prisma.ParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          create: {
            args: Prisma.ParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          createMany: {
            args: Prisma.ParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          delete: {
            args: Prisma.ParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          update: {
            args: Prisma.ParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipantPayload>
          }
          aggregate: {
            args: Prisma.ParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipant>
          }
          groupBy: {
            args: Prisma.ParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipantCountAggregateOutputType> | number
          }
        }
      }
      Judge: {
        payload: Prisma.$JudgePayload<ExtArgs>
        fields: Prisma.JudgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JudgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JudgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>
          }
          findFirst: {
            args: Prisma.JudgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JudgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>
          }
          findMany: {
            args: Prisma.JudgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>[]
          }
          create: {
            args: Prisma.JudgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>
          }
          createMany: {
            args: Prisma.JudgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JudgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>[]
          }
          delete: {
            args: Prisma.JudgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>
          }
          update: {
            args: Prisma.JudgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>
          }
          deleteMany: {
            args: Prisma.JudgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JudgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JudgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>[]
          }
          upsert: {
            args: Prisma.JudgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JudgePayload>
          }
          aggregate: {
            args: Prisma.JudgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJudge>
          }
          groupBy: {
            args: Prisma.JudgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<JudgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.JudgeCountArgs<ExtArgs>
            result: $Utils.Optional<JudgeCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Round: {
        payload: Prisma.$RoundPayload<ExtArgs>
        fields: Prisma.RoundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          findFirst: {
            args: Prisma.RoundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          findMany: {
            args: Prisma.RoundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>[]
          }
          create: {
            args: Prisma.RoundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          createMany: {
            args: Prisma.RoundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>[]
          }
          delete: {
            args: Prisma.RoundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          update: {
            args: Prisma.RoundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          deleteMany: {
            args: Prisma.RoundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>[]
          }
          upsert: {
            args: Prisma.RoundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundPayload>
          }
          aggregate: {
            args: Prisma.RoundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRound>
          }
          groupBy: {
            args: Prisma.RoundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoundCountArgs<ExtArgs>
            result: $Utils.Optional<RoundCountAggregateOutputType> | number
          }
        }
      }
      RoundAssignment: {
        payload: Prisma.$RoundAssignmentPayload<ExtArgs>
        fields: Prisma.RoundAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoundAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoundAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>
          }
          findFirst: {
            args: Prisma.RoundAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoundAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>
          }
          findMany: {
            args: Prisma.RoundAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>[]
          }
          create: {
            args: Prisma.RoundAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>
          }
          createMany: {
            args: Prisma.RoundAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoundAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>[]
          }
          delete: {
            args: Prisma.RoundAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>
          }
          update: {
            args: Prisma.RoundAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.RoundAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoundAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoundAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.RoundAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoundAssignmentPayload>
          }
          aggregate: {
            args: Prisma.RoundAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoundAssignment>
          }
          groupBy: {
            args: Prisma.RoundAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoundAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoundAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<RoundAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Score: {
        payload: Prisma.$ScorePayload<ExtArgs>
        fields: Prisma.ScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          findFirst: {
            args: Prisma.ScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          findMany: {
            args: Prisma.ScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[]
          }
          create: {
            args: Prisma.ScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          createMany: {
            args: Prisma.ScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[]
          }
          delete: {
            args: Prisma.ScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          update: {
            args: Prisma.ScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          deleteMany: {
            args: Prisma.ScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>[]
          }
          upsert: {
            args: Prisma.ScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScorePayload>
          }
          aggregate: {
            args: Prisma.ScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScore>
          }
          groupBy: {
            args: Prisma.ScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScoreCountArgs<ExtArgs>
            result: $Utils.Optional<ScoreCountAggregateOutputType> | number
          }
        }
      }
      MatchResult: {
        payload: Prisma.$MatchResultPayload<ExtArgs>
        fields: Prisma.MatchResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>
          }
          findFirst: {
            args: Prisma.MatchResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>
          }
          findMany: {
            args: Prisma.MatchResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>[]
          }
          create: {
            args: Prisma.MatchResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>
          }
          createMany: {
            args: Prisma.MatchResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>[]
          }
          delete: {
            args: Prisma.MatchResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>
          }
          update: {
            args: Prisma.MatchResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>
          }
          deleteMany: {
            args: Prisma.MatchResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>[]
          }
          upsert: {
            args: Prisma.MatchResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchResultPayload>
          }
          aggregate: {
            args: Prisma.MatchResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchResult>
          }
          groupBy: {
            args: Prisma.MatchResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchResultCountArgs<ExtArgs>
            result: $Utils.Optional<MatchResultCountAggregateOutputType> | number
          }
        }
      }
      TeamAssignment: {
        payload: Prisma.$TeamAssignmentPayload<ExtArgs>
        fields: Prisma.TeamAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>
          }
          findFirst: {
            args: Prisma.TeamAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>
          }
          findMany: {
            args: Prisma.TeamAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>[]
          }
          create: {
            args: Prisma.TeamAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>
          }
          createMany: {
            args: Prisma.TeamAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>[]
          }
          delete: {
            args: Prisma.TeamAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>
          }
          update: {
            args: Prisma.TeamAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.TeamAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.TeamAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamAssignmentPayload>
          }
          aggregate: {
            args: Prisma.TeamAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamAssignment>
          }
          groupBy: {
            args: Prisma.TeamAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<TeamAssignmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    team?: TeamOmit
    participant?: ParticipantOmit
    judge?: JudgeOmit
    room?: RoomOmit
    round?: RoundOmit
    roundAssignment?: RoundAssignmentOmit
    score?: ScoreOmit
    matchResult?: MatchResultOmit
    teamAssignment?: TeamAssignmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    participants: number
    scores: number
    matchResults: number
    teamAssignments: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | TeamCountOutputTypeCountParticipantsArgs
    scores?: boolean | TeamCountOutputTypeCountScoresArgs
    matchResults?: boolean | TeamCountOutputTypeCountMatchResultsArgs
    teamAssignments?: boolean | TeamCountOutputTypeCountTeamAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMatchResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchResultWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAssignmentWhereInput
  }


  /**
   * Count Type ParticipantCountOutputType
   */

  export type ParticipantCountOutputType = {
    scores: number
  }

  export type ParticipantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scores?: boolean | ParticipantCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipantCountOutputType
     */
    select?: ParticipantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParticipantCountOutputType without action
   */
  export type ParticipantCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
  }


  /**
   * Count Type JudgeCountOutputType
   */

  export type JudgeCountOutputType = {
    assignments: number
    scores: number
  }

  export type JudgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | JudgeCountOutputTypeCountAssignmentsArgs
    scores?: boolean | JudgeCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * JudgeCountOutputType without action
   */
  export type JudgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JudgeCountOutputType
     */
    select?: JudgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JudgeCountOutputType without action
   */
  export type JudgeCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundAssignmentWhereInput
  }

  /**
   * JudgeCountOutputType without action
   */
  export type JudgeCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    assignments: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | RoomCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundAssignmentWhereInput
  }


  /**
   * Count Type RoundCountOutputType
   */

  export type RoundCountOutputType = {
    assignments: number
    Score: number
  }

  export type RoundCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | RoundCountOutputTypeCountAssignmentsArgs
    Score?: boolean | RoundCountOutputTypeCountScoreArgs
  }

  // Custom InputTypes
  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundCountOutputType
     */
    select?: RoundCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundAssignmentWhereInput
  }

  /**
   * RoundCountOutputType without action
   */
  export type RoundCountOutputTypeCountScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
  }


  /**
   * Count Type RoundAssignmentCountOutputType
   */

  export type RoundAssignmentCountOutputType = {
    matchResults: number
    teamAssignments: number
  }

  export type RoundAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchResults?: boolean | RoundAssignmentCountOutputTypeCountMatchResultsArgs
    teamAssignments?: boolean | RoundAssignmentCountOutputTypeCountTeamAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * RoundAssignmentCountOutputType without action
   */
  export type RoundAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignmentCountOutputType
     */
    select?: RoundAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoundAssignmentCountOutputType without action
   */
  export type RoundAssignmentCountOutputTypeCountMatchResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchResultWhereInput
  }

  /**
   * RoundAssignmentCountOutputType without action
   */
  export type RoundAssignmentCountOutputTypeCountTeamAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    participants?: boolean | Team$participantsArgs<ExtArgs>
    scores?: boolean | Team$scoresArgs<ExtArgs>
    matchResults?: boolean | Team$matchResultsArgs<ExtArgs>
    teamAssignments?: boolean | Team$teamAssignmentsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | Team$participantsArgs<ExtArgs>
    scores?: boolean | Team$scoresArgs<ExtArgs>
    matchResults?: boolean | Team$matchResultsArgs<ExtArgs>
    teamAssignments?: boolean | Team$teamAssignmentsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      participants: Prisma.$ParticipantPayload<ExtArgs>[]
      scores: Prisma.$ScorePayload<ExtArgs>[]
      matchResults: Prisma.$MatchResultPayload<ExtArgs>[]
      teamAssignments: Prisma.$TeamAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends Team$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Team$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scores<T extends Team$scoresArgs<ExtArgs> = {}>(args?: Subset<T, Team$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchResults<T extends Team$matchResultsArgs<ExtArgs> = {}>(args?: Subset<T, Team$matchResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamAssignments<T extends Team$teamAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.participants
   */
  export type Team$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    cursor?: ParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Team.scores
   */
  export type Team$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    cursor?: ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Team.matchResults
   */
  export type Team$matchResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    where?: MatchResultWhereInput
    orderBy?: MatchResultOrderByWithRelationInput | MatchResultOrderByWithRelationInput[]
    cursor?: MatchResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchResultScalarFieldEnum | MatchResultScalarFieldEnum[]
  }

  /**
   * Team.teamAssignments
   */
  export type Team$teamAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    where?: TeamAssignmentWhereInput
    orderBy?: TeamAssignmentOrderByWithRelationInput | TeamAssignmentOrderByWithRelationInput[]
    cursor?: TeamAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamAssignmentScalarFieldEnum | TeamAssignmentScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Participant
   */

  export type AggregateParticipant = {
    _count: ParticipantCountAggregateOutputType | null
    _avg: ParticipantAvgAggregateOutputType | null
    _sum: ParticipantSumAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  export type ParticipantAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type ParticipantSumAggregateOutputType = {
    id: number | null
    teamId: number | null
  }

  export type ParticipantMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    teamId: number | null
  }

  export type ParticipantMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    teamId: number | null
  }

  export type ParticipantCountAggregateOutputType = {
    id: number
    name: number
    email: number
    teamId: number
    _all: number
  }


  export type ParticipantAvgAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type ParticipantSumAggregateInputType = {
    id?: true
    teamId?: true
  }

  export type ParticipantMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    teamId?: true
  }

  export type ParticipantMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    teamId?: true
  }

  export type ParticipantCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    teamId?: true
    _all?: true
  }

  export type ParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participant to aggregate.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Participants
    **/
    _count?: true | ParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipantMaxAggregateInputType
  }

  export type GetParticipantAggregateType<T extends ParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipant[P]>
      : GetScalarType<T[P], AggregateParticipant[P]>
  }




  export type ParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipantWhereInput
    orderBy?: ParticipantOrderByWithAggregationInput | ParticipantOrderByWithAggregationInput[]
    by: ParticipantScalarFieldEnum[] | ParticipantScalarFieldEnum
    having?: ParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipantCountAggregateInputType | true
    _avg?: ParticipantAvgAggregateInputType
    _sum?: ParticipantSumAggregateInputType
    _min?: ParticipantMinAggregateInputType
    _max?: ParticipantMaxAggregateInputType
  }

  export type ParticipantGroupByOutputType = {
    id: number
    name: string
    email: string
    teamId: number
    _count: ParticipantCountAggregateOutputType | null
    _avg: ParticipantAvgAggregateOutputType | null
    _sum: ParticipantSumAggregateOutputType | null
    _min: ParticipantMinAggregateOutputType | null
    _max: ParticipantMaxAggregateOutputType | null
  }

  type GetParticipantGroupByPayload<T extends ParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    scores?: boolean | Participant$scoresArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    teamId?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participant"]>

  export type ParticipantSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    teamId?: boolean
  }

  export type ParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "teamId", ExtArgs["result"]["participant"]>
  export type ParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    scores?: boolean | Participant$scoresArgs<ExtArgs>
    _count?: boolean | ParticipantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type ParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $ParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Participant"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      scores: Prisma.$ScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      teamId: number
    }, ExtArgs["result"]["participant"]>
    composites: {}
  }

  type ParticipantGetPayload<S extends boolean | null | undefined | ParticipantDefaultArgs> = $Result.GetResult<Prisma.$ParticipantPayload, S>

  type ParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParticipantCountAggregateInputType | true
    }

  export interface ParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Participant'], meta: { name: 'Participant' } }
    /**
     * Find zero or one Participant that matches the filter.
     * @param {ParticipantFindUniqueArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipantFindUniqueArgs>(args: SelectSubset<T, ParticipantFindUniqueArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Participant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParticipantFindUniqueOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipantFindFirstArgs>(args?: SelectSubset<T, ParticipantFindFirstArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindFirstOrThrowArgs} args - Arguments to find a Participant
     * @example
     * // Get one Participant
     * const participant = await prisma.participant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Participants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participants
     * const participants = await prisma.participant.findMany()
     * 
     * // Get first 10 Participants
     * const participants = await prisma.participant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participantWithIdOnly = await prisma.participant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParticipantFindManyArgs>(args?: SelectSubset<T, ParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Participant.
     * @param {ParticipantCreateArgs} args - Arguments to create a Participant.
     * @example
     * // Create one Participant
     * const Participant = await prisma.participant.create({
     *   data: {
     *     // ... data to create a Participant
     *   }
     * })
     * 
     */
    create<T extends ParticipantCreateArgs>(args: SelectSubset<T, ParticipantCreateArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Participants.
     * @param {ParticipantCreateManyArgs} args - Arguments to create many Participants.
     * @example
     * // Create many Participants
     * const participant = await prisma.participant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParticipantCreateManyArgs>(args?: SelectSubset<T, ParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Participants and returns the data saved in the database.
     * @param {ParticipantCreateManyAndReturnArgs} args - Arguments to create many Participants.
     * @example
     * // Create many Participants
     * const participant = await prisma.participant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Participants and only return the `id`
     * const participantWithIdOnly = await prisma.participant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Participant.
     * @param {ParticipantDeleteArgs} args - Arguments to delete one Participant.
     * @example
     * // Delete one Participant
     * const Participant = await prisma.participant.delete({
     *   where: {
     *     // ... filter to delete one Participant
     *   }
     * })
     * 
     */
    delete<T extends ParticipantDeleteArgs>(args: SelectSubset<T, ParticipantDeleteArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Participant.
     * @param {ParticipantUpdateArgs} args - Arguments to update one Participant.
     * @example
     * // Update one Participant
     * const participant = await prisma.participant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParticipantUpdateArgs>(args: SelectSubset<T, ParticipantUpdateArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Participants.
     * @param {ParticipantDeleteManyArgs} args - Arguments to filter Participants to delete.
     * @example
     * // Delete a few Participants
     * const { count } = await prisma.participant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParticipantDeleteManyArgs>(args?: SelectSubset<T, ParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParticipantUpdateManyArgs>(args: SelectSubset<T, ParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participants and returns the data updated in the database.
     * @param {ParticipantUpdateManyAndReturnArgs} args - Arguments to update many Participants.
     * @example
     * // Update many Participants
     * const participant = await prisma.participant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Participants and only return the `id`
     * const participantWithIdOnly = await prisma.participant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Participant.
     * @param {ParticipantUpsertArgs} args - Arguments to update or create a Participant.
     * @example
     * // Update or create a Participant
     * const participant = await prisma.participant.upsert({
     *   create: {
     *     // ... data to create a Participant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participant we want to update
     *   }
     * })
     */
    upsert<T extends ParticipantUpsertArgs>(args: SelectSubset<T, ParticipantUpsertArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Participants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantCountArgs} args - Arguments to filter Participants to count.
     * @example
     * // Count the number of Participants
     * const count = await prisma.participant.count({
     *   where: {
     *     // ... the filter for the Participants we want to count
     *   }
     * })
    **/
    count<T extends ParticipantCountArgs>(
      args?: Subset<T, ParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipantAggregateArgs>(args: Subset<T, ParticipantAggregateArgs>): Prisma.PrismaPromise<GetParticipantAggregateType<T>>

    /**
     * Group by Participant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Participant model
   */
  readonly fields: ParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Participant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scores<T extends Participant$scoresArgs<ExtArgs> = {}>(args?: Subset<T, Participant$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Participant model
   */
  interface ParticipantFieldRefs {
    readonly id: FieldRef<"Participant", 'Int'>
    readonly name: FieldRef<"Participant", 'String'>
    readonly email: FieldRef<"Participant", 'String'>
    readonly teamId: FieldRef<"Participant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Participant findUnique
   */
  export type ParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findUniqueOrThrow
   */
  export type ParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant findFirst
   */
  export type ParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant findFirstOrThrow
   */
  export type ParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participant to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participants.
     */
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant findMany
   */
  export type ParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter, which Participants to fetch.
     */
    where?: ParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participants to fetch.
     */
    orderBy?: ParticipantOrderByWithRelationInput | ParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Participants.
     */
    cursor?: ParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participants.
     */
    skip?: number
    distinct?: ParticipantScalarFieldEnum | ParticipantScalarFieldEnum[]
  }

  /**
   * Participant create
   */
  export type ParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a Participant.
     */
    data: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
  }

  /**
   * Participant createMany
   */
  export type ParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Participant createManyAndReturn
   */
  export type ParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many Participants.
     */
    data: ParticipantCreateManyInput | ParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Participant update
   */
  export type ParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a Participant.
     */
    data: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
    /**
     * Choose, which Participant to update.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant updateMany
   */
  export type ParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to update.
     */
    limit?: number
  }

  /**
   * Participant updateManyAndReturn
   */
  export type ParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * The data used to update Participants.
     */
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyInput>
    /**
     * Filter which Participants to update
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Participant upsert
   */
  export type ParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the Participant to update in case it exists.
     */
    where: ParticipantWhereUniqueInput
    /**
     * In case the Participant found by the `where` argument doesn't exist, create a new Participant with this data.
     */
    create: XOR<ParticipantCreateInput, ParticipantUncheckedCreateInput>
    /**
     * In case the Participant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipantUpdateInput, ParticipantUncheckedUpdateInput>
  }

  /**
   * Participant delete
   */
  export type ParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    /**
     * Filter which Participant to delete.
     */
    where: ParticipantWhereUniqueInput
  }

  /**
   * Participant deleteMany
   */
  export type ParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participants to delete
     */
    where?: ParticipantWhereInput
    /**
     * Limit how many Participants to delete.
     */
    limit?: number
  }

  /**
   * Participant.scores
   */
  export type Participant$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    cursor?: ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Participant without action
   */
  export type ParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Judge
   */

  export type AggregateJudge = {
    _count: JudgeCountAggregateOutputType | null
    _avg: JudgeAvgAggregateOutputType | null
    _sum: JudgeSumAggregateOutputType | null
    _min: JudgeMinAggregateOutputType | null
    _max: JudgeMaxAggregateOutputType | null
  }

  export type JudgeAvgAggregateOutputType = {
    id: number | null
  }

  export type JudgeSumAggregateOutputType = {
    id: number | null
  }

  export type JudgeMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type JudgeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type JudgeCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    _all: number
  }


  export type JudgeAvgAggregateInputType = {
    id?: true
  }

  export type JudgeSumAggregateInputType = {
    id?: true
  }

  export type JudgeMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
  }

  export type JudgeMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
  }

  export type JudgeCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type JudgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Judge to aggregate.
     */
    where?: JudgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JudgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Judges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Judges
    **/
    _count?: true | JudgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JudgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JudgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JudgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JudgeMaxAggregateInputType
  }

  export type GetJudgeAggregateType<T extends JudgeAggregateArgs> = {
        [P in keyof T & keyof AggregateJudge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJudge[P]>
      : GetScalarType<T[P], AggregateJudge[P]>
  }




  export type JudgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JudgeWhereInput
    orderBy?: JudgeOrderByWithAggregationInput | JudgeOrderByWithAggregationInput[]
    by: JudgeScalarFieldEnum[] | JudgeScalarFieldEnum
    having?: JudgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JudgeCountAggregateInputType | true
    _avg?: JudgeAvgAggregateInputType
    _sum?: JudgeSumAggregateInputType
    _min?: JudgeMinAggregateInputType
    _max?: JudgeMaxAggregateInputType
  }

  export type JudgeGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    _count: JudgeCountAggregateOutputType | null
    _avg: JudgeAvgAggregateOutputType | null
    _sum: JudgeSumAggregateOutputType | null
    _min: JudgeMinAggregateOutputType | null
    _max: JudgeMaxAggregateOutputType | null
  }

  type GetJudgeGroupByPayload<T extends JudgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JudgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JudgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JudgeGroupByOutputType[P]>
            : GetScalarType<T[P], JudgeGroupByOutputType[P]>
        }
      >
    >


  export type JudgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    assignments?: boolean | Judge$assignmentsArgs<ExtArgs>
    scores?: boolean | Judge$scoresArgs<ExtArgs>
    _count?: boolean | JudgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["judge"]>

  export type JudgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["judge"]>

  export type JudgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["judge"]>

  export type JudgeSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }

  export type JudgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password", ExtArgs["result"]["judge"]>
  export type JudgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Judge$assignmentsArgs<ExtArgs>
    scores?: boolean | Judge$scoresArgs<ExtArgs>
    _count?: boolean | JudgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JudgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type JudgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JudgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Judge"
    objects: {
      assignments: Prisma.$RoundAssignmentPayload<ExtArgs>[]
      scores: Prisma.$ScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
    }, ExtArgs["result"]["judge"]>
    composites: {}
  }

  type JudgeGetPayload<S extends boolean | null | undefined | JudgeDefaultArgs> = $Result.GetResult<Prisma.$JudgePayload, S>

  type JudgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JudgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JudgeCountAggregateInputType | true
    }

  export interface JudgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Judge'], meta: { name: 'Judge' } }
    /**
     * Find zero or one Judge that matches the filter.
     * @param {JudgeFindUniqueArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JudgeFindUniqueArgs>(args: SelectSubset<T, JudgeFindUniqueArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Judge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JudgeFindUniqueOrThrowArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JudgeFindUniqueOrThrowArgs>(args: SelectSubset<T, JudgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Judge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeFindFirstArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JudgeFindFirstArgs>(args?: SelectSubset<T, JudgeFindFirstArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Judge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeFindFirstOrThrowArgs} args - Arguments to find a Judge
     * @example
     * // Get one Judge
     * const judge = await prisma.judge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JudgeFindFirstOrThrowArgs>(args?: SelectSubset<T, JudgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Judges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Judges
     * const judges = await prisma.judge.findMany()
     * 
     * // Get first 10 Judges
     * const judges = await prisma.judge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const judgeWithIdOnly = await prisma.judge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JudgeFindManyArgs>(args?: SelectSubset<T, JudgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Judge.
     * @param {JudgeCreateArgs} args - Arguments to create a Judge.
     * @example
     * // Create one Judge
     * const Judge = await prisma.judge.create({
     *   data: {
     *     // ... data to create a Judge
     *   }
     * })
     * 
     */
    create<T extends JudgeCreateArgs>(args: SelectSubset<T, JudgeCreateArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Judges.
     * @param {JudgeCreateManyArgs} args - Arguments to create many Judges.
     * @example
     * // Create many Judges
     * const judge = await prisma.judge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JudgeCreateManyArgs>(args?: SelectSubset<T, JudgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Judges and returns the data saved in the database.
     * @param {JudgeCreateManyAndReturnArgs} args - Arguments to create many Judges.
     * @example
     * // Create many Judges
     * const judge = await prisma.judge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Judges and only return the `id`
     * const judgeWithIdOnly = await prisma.judge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JudgeCreateManyAndReturnArgs>(args?: SelectSubset<T, JudgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Judge.
     * @param {JudgeDeleteArgs} args - Arguments to delete one Judge.
     * @example
     * // Delete one Judge
     * const Judge = await prisma.judge.delete({
     *   where: {
     *     // ... filter to delete one Judge
     *   }
     * })
     * 
     */
    delete<T extends JudgeDeleteArgs>(args: SelectSubset<T, JudgeDeleteArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Judge.
     * @param {JudgeUpdateArgs} args - Arguments to update one Judge.
     * @example
     * // Update one Judge
     * const judge = await prisma.judge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JudgeUpdateArgs>(args: SelectSubset<T, JudgeUpdateArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Judges.
     * @param {JudgeDeleteManyArgs} args - Arguments to filter Judges to delete.
     * @example
     * // Delete a few Judges
     * const { count } = await prisma.judge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JudgeDeleteManyArgs>(args?: SelectSubset<T, JudgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Judges
     * const judge = await prisma.judge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JudgeUpdateManyArgs>(args: SelectSubset<T, JudgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Judges and returns the data updated in the database.
     * @param {JudgeUpdateManyAndReturnArgs} args - Arguments to update many Judges.
     * @example
     * // Update many Judges
     * const judge = await prisma.judge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Judges and only return the `id`
     * const judgeWithIdOnly = await prisma.judge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JudgeUpdateManyAndReturnArgs>(args: SelectSubset<T, JudgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Judge.
     * @param {JudgeUpsertArgs} args - Arguments to update or create a Judge.
     * @example
     * // Update or create a Judge
     * const judge = await prisma.judge.upsert({
     *   create: {
     *     // ... data to create a Judge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Judge we want to update
     *   }
     * })
     */
    upsert<T extends JudgeUpsertArgs>(args: SelectSubset<T, JudgeUpsertArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Judges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeCountArgs} args - Arguments to filter Judges to count.
     * @example
     * // Count the number of Judges
     * const count = await prisma.judge.count({
     *   where: {
     *     // ... the filter for the Judges we want to count
     *   }
     * })
    **/
    count<T extends JudgeCountArgs>(
      args?: Subset<T, JudgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JudgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Judge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JudgeAggregateArgs>(args: Subset<T, JudgeAggregateArgs>): Prisma.PrismaPromise<GetJudgeAggregateType<T>>

    /**
     * Group by Judge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JudgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JudgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JudgeGroupByArgs['orderBy'] }
        : { orderBy?: JudgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JudgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJudgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Judge model
   */
  readonly fields: JudgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Judge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JudgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Judge$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Judge$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scores<T extends Judge$scoresArgs<ExtArgs> = {}>(args?: Subset<T, Judge$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Judge model
   */
  interface JudgeFieldRefs {
    readonly id: FieldRef<"Judge", 'Int'>
    readonly name: FieldRef<"Judge", 'String'>
    readonly email: FieldRef<"Judge", 'String'>
    readonly password: FieldRef<"Judge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Judge findUnique
   */
  export type JudgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * Filter, which Judge to fetch.
     */
    where: JudgeWhereUniqueInput
  }

  /**
   * Judge findUniqueOrThrow
   */
  export type JudgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * Filter, which Judge to fetch.
     */
    where: JudgeWhereUniqueInput
  }

  /**
   * Judge findFirst
   */
  export type JudgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * Filter, which Judge to fetch.
     */
    where?: JudgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Judges.
     */
    cursor?: JudgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Judges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Judges.
     */
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[]
  }

  /**
   * Judge findFirstOrThrow
   */
  export type JudgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * Filter, which Judge to fetch.
     */
    where?: JudgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Judges.
     */
    cursor?: JudgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Judges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Judges.
     */
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[]
  }

  /**
   * Judge findMany
   */
  export type JudgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * Filter, which Judges to fetch.
     */
    where?: JudgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Judges to fetch.
     */
    orderBy?: JudgeOrderByWithRelationInput | JudgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Judges.
     */
    cursor?: JudgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Judges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Judges.
     */
    skip?: number
    distinct?: JudgeScalarFieldEnum | JudgeScalarFieldEnum[]
  }

  /**
   * Judge create
   */
  export type JudgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Judge.
     */
    data: XOR<JudgeCreateInput, JudgeUncheckedCreateInput>
  }

  /**
   * Judge createMany
   */
  export type JudgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Judges.
     */
    data: JudgeCreateManyInput | JudgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Judge createManyAndReturn
   */
  export type JudgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * The data used to create many Judges.
     */
    data: JudgeCreateManyInput | JudgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Judge update
   */
  export type JudgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Judge.
     */
    data: XOR<JudgeUpdateInput, JudgeUncheckedUpdateInput>
    /**
     * Choose, which Judge to update.
     */
    where: JudgeWhereUniqueInput
  }

  /**
   * Judge updateMany
   */
  export type JudgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Judges.
     */
    data: XOR<JudgeUpdateManyMutationInput, JudgeUncheckedUpdateManyInput>
    /**
     * Filter which Judges to update
     */
    where?: JudgeWhereInput
    /**
     * Limit how many Judges to update.
     */
    limit?: number
  }

  /**
   * Judge updateManyAndReturn
   */
  export type JudgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * The data used to update Judges.
     */
    data: XOR<JudgeUpdateManyMutationInput, JudgeUncheckedUpdateManyInput>
    /**
     * Filter which Judges to update
     */
    where?: JudgeWhereInput
    /**
     * Limit how many Judges to update.
     */
    limit?: number
  }

  /**
   * Judge upsert
   */
  export type JudgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Judge to update in case it exists.
     */
    where: JudgeWhereUniqueInput
    /**
     * In case the Judge found by the `where` argument doesn't exist, create a new Judge with this data.
     */
    create: XOR<JudgeCreateInput, JudgeUncheckedCreateInput>
    /**
     * In case the Judge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JudgeUpdateInput, JudgeUncheckedUpdateInput>
  }

  /**
   * Judge delete
   */
  export type JudgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    /**
     * Filter which Judge to delete.
     */
    where: JudgeWhereUniqueInput
  }

  /**
   * Judge deleteMany
   */
  export type JudgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Judges to delete
     */
    where?: JudgeWhereInput
    /**
     * Limit how many Judges to delete.
     */
    limit?: number
  }

  /**
   * Judge.assignments
   */
  export type Judge$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    where?: RoundAssignmentWhereInput
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    cursor?: RoundAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundAssignmentScalarFieldEnum | RoundAssignmentScalarFieldEnum[]
  }

  /**
   * Judge.scores
   */
  export type Judge$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    cursor?: ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Judge without action
   */
  export type JudgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    name: string
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    assignments?: boolean | Room$assignmentsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Room$assignmentsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      assignments: Prisma.$RoundAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Room$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Room$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly name: FieldRef<"Room", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.assignments
   */
  export type Room$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    where?: RoundAssignmentWhereInput
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    cursor?: RoundAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundAssignmentScalarFieldEnum | RoundAssignmentScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Round
   */

  export type AggregateRound = {
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  export type RoundAvgAggregateOutputType = {
    id: number | null
    number: number | null
  }

  export type RoundSumAggregateOutputType = {
    id: number | null
    number: number | null
  }

  export type RoundMinAggregateOutputType = {
    id: number | null
    name: string | null
    number: number | null
  }

  export type RoundMaxAggregateOutputType = {
    id: number | null
    name: string | null
    number: number | null
  }

  export type RoundCountAggregateOutputType = {
    id: number
    name: number
    number: number
    _all: number
  }


  export type RoundAvgAggregateInputType = {
    id?: true
    number?: true
  }

  export type RoundSumAggregateInputType = {
    id?: true
    number?: true
  }

  export type RoundMinAggregateInputType = {
    id?: true
    name?: true
    number?: true
  }

  export type RoundMaxAggregateInputType = {
    id?: true
    name?: true
    number?: true
  }

  export type RoundCountAggregateInputType = {
    id?: true
    name?: true
    number?: true
    _all?: true
  }

  export type RoundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Round to aggregate.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rounds
    **/
    _count?: true | RoundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundMaxAggregateInputType
  }

  export type GetRoundAggregateType<T extends RoundAggregateArgs> = {
        [P in keyof T & keyof AggregateRound]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRound[P]>
      : GetScalarType<T[P], AggregateRound[P]>
  }




  export type RoundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundWhereInput
    orderBy?: RoundOrderByWithAggregationInput | RoundOrderByWithAggregationInput[]
    by: RoundScalarFieldEnum[] | RoundScalarFieldEnum
    having?: RoundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundCountAggregateInputType | true
    _avg?: RoundAvgAggregateInputType
    _sum?: RoundSumAggregateInputType
    _min?: RoundMinAggregateInputType
    _max?: RoundMaxAggregateInputType
  }

  export type RoundGroupByOutputType = {
    id: number
    name: string
    number: number
    _count: RoundCountAggregateOutputType | null
    _avg: RoundAvgAggregateOutputType | null
    _sum: RoundSumAggregateOutputType | null
    _min: RoundMinAggregateOutputType | null
    _max: RoundMaxAggregateOutputType | null
  }

  type GetRoundGroupByPayload<T extends RoundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundGroupByOutputType[P]>
            : GetScalarType<T[P], RoundGroupByOutputType[P]>
        }
      >
    >


  export type RoundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    number?: boolean
    assignments?: boolean | Round$assignmentsArgs<ExtArgs>
    Score?: boolean | Round$ScoreArgs<ExtArgs>
    _count?: boolean | RoundCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["round"]>

  export type RoundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    number?: boolean
  }, ExtArgs["result"]["round"]>

  export type RoundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    number?: boolean
  }, ExtArgs["result"]["round"]>

  export type RoundSelectScalar = {
    id?: boolean
    name?: boolean
    number?: boolean
  }

  export type RoundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "number", ExtArgs["result"]["round"]>
  export type RoundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Round$assignmentsArgs<ExtArgs>
    Score?: boolean | Round$ScoreArgs<ExtArgs>
    _count?: boolean | RoundCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoundIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Round"
    objects: {
      assignments: Prisma.$RoundAssignmentPayload<ExtArgs>[]
      Score: Prisma.$ScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      number: number
    }, ExtArgs["result"]["round"]>
    composites: {}
  }

  type RoundGetPayload<S extends boolean | null | undefined | RoundDefaultArgs> = $Result.GetResult<Prisma.$RoundPayload, S>

  type RoundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoundCountAggregateInputType | true
    }

  export interface RoundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Round'], meta: { name: 'Round' } }
    /**
     * Find zero or one Round that matches the filter.
     * @param {RoundFindUniqueArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoundFindUniqueArgs>(args: SelectSubset<T, RoundFindUniqueArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Round that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoundFindUniqueOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoundFindUniqueOrThrowArgs>(args: SelectSubset<T, RoundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Round that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoundFindFirstArgs>(args?: SelectSubset<T, RoundFindFirstArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Round that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindFirstOrThrowArgs} args - Arguments to find a Round
     * @example
     * // Get one Round
     * const round = await prisma.round.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoundFindFirstOrThrowArgs>(args?: SelectSubset<T, RoundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rounds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rounds
     * const rounds = await prisma.round.findMany()
     * 
     * // Get first 10 Rounds
     * const rounds = await prisma.round.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundWithIdOnly = await prisma.round.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoundFindManyArgs>(args?: SelectSubset<T, RoundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Round.
     * @param {RoundCreateArgs} args - Arguments to create a Round.
     * @example
     * // Create one Round
     * const Round = await prisma.round.create({
     *   data: {
     *     // ... data to create a Round
     *   }
     * })
     * 
     */
    create<T extends RoundCreateArgs>(args: SelectSubset<T, RoundCreateArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rounds.
     * @param {RoundCreateManyArgs} args - Arguments to create many Rounds.
     * @example
     * // Create many Rounds
     * const round = await prisma.round.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoundCreateManyArgs>(args?: SelectSubset<T, RoundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rounds and returns the data saved in the database.
     * @param {RoundCreateManyAndReturnArgs} args - Arguments to create many Rounds.
     * @example
     * // Create many Rounds
     * const round = await prisma.round.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rounds and only return the `id`
     * const roundWithIdOnly = await prisma.round.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoundCreateManyAndReturnArgs>(args?: SelectSubset<T, RoundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Round.
     * @param {RoundDeleteArgs} args - Arguments to delete one Round.
     * @example
     * // Delete one Round
     * const Round = await prisma.round.delete({
     *   where: {
     *     // ... filter to delete one Round
     *   }
     * })
     * 
     */
    delete<T extends RoundDeleteArgs>(args: SelectSubset<T, RoundDeleteArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Round.
     * @param {RoundUpdateArgs} args - Arguments to update one Round.
     * @example
     * // Update one Round
     * const round = await prisma.round.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoundUpdateArgs>(args: SelectSubset<T, RoundUpdateArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rounds.
     * @param {RoundDeleteManyArgs} args - Arguments to filter Rounds to delete.
     * @example
     * // Delete a few Rounds
     * const { count } = await prisma.round.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoundDeleteManyArgs>(args?: SelectSubset<T, RoundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rounds
     * const round = await prisma.round.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoundUpdateManyArgs>(args: SelectSubset<T, RoundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rounds and returns the data updated in the database.
     * @param {RoundUpdateManyAndReturnArgs} args - Arguments to update many Rounds.
     * @example
     * // Update many Rounds
     * const round = await prisma.round.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rounds and only return the `id`
     * const roundWithIdOnly = await prisma.round.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoundUpdateManyAndReturnArgs>(args: SelectSubset<T, RoundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Round.
     * @param {RoundUpsertArgs} args - Arguments to update or create a Round.
     * @example
     * // Update or create a Round
     * const round = await prisma.round.upsert({
     *   create: {
     *     // ... data to create a Round
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Round we want to update
     *   }
     * })
     */
    upsert<T extends RoundUpsertArgs>(args: SelectSubset<T, RoundUpsertArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rounds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundCountArgs} args - Arguments to filter Rounds to count.
     * @example
     * // Count the number of Rounds
     * const count = await prisma.round.count({
     *   where: {
     *     // ... the filter for the Rounds we want to count
     *   }
     * })
    **/
    count<T extends RoundCountArgs>(
      args?: Subset<T, RoundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundAggregateArgs>(args: Subset<T, RoundAggregateArgs>): Prisma.PrismaPromise<GetRoundAggregateType<T>>

    /**
     * Group by Round.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundGroupByArgs['orderBy'] }
        : { orderBy?: RoundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Round model
   */
  readonly fields: RoundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Round.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Round$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Round$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Score<T extends Round$ScoreArgs<ExtArgs> = {}>(args?: Subset<T, Round$ScoreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Round model
   */
  interface RoundFieldRefs {
    readonly id: FieldRef<"Round", 'Int'>
    readonly name: FieldRef<"Round", 'String'>
    readonly number: FieldRef<"Round", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Round findUnique
   */
  export type RoundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round findUniqueOrThrow
   */
  export type RoundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round findFirst
   */
  export type RoundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Round findFirstOrThrow
   */
  export type RoundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Round to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rounds.
     */
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Round findMany
   */
  export type RoundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter, which Rounds to fetch.
     */
    where?: RoundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rounds to fetch.
     */
    orderBy?: RoundOrderByWithRelationInput | RoundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rounds.
     */
    cursor?: RoundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rounds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rounds.
     */
    skip?: number
    distinct?: RoundScalarFieldEnum | RoundScalarFieldEnum[]
  }

  /**
   * Round create
   */
  export type RoundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * The data needed to create a Round.
     */
    data: XOR<RoundCreateInput, RoundUncheckedCreateInput>
  }

  /**
   * Round createMany
   */
  export type RoundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rounds.
     */
    data: RoundCreateManyInput | RoundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Round createManyAndReturn
   */
  export type RoundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * The data used to create many Rounds.
     */
    data: RoundCreateManyInput | RoundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Round update
   */
  export type RoundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * The data needed to update a Round.
     */
    data: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
    /**
     * Choose, which Round to update.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round updateMany
   */
  export type RoundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rounds.
     */
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyInput>
    /**
     * Filter which Rounds to update
     */
    where?: RoundWhereInput
    /**
     * Limit how many Rounds to update.
     */
    limit?: number
  }

  /**
   * Round updateManyAndReturn
   */
  export type RoundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * The data used to update Rounds.
     */
    data: XOR<RoundUpdateManyMutationInput, RoundUncheckedUpdateManyInput>
    /**
     * Filter which Rounds to update
     */
    where?: RoundWhereInput
    /**
     * Limit how many Rounds to update.
     */
    limit?: number
  }

  /**
   * Round upsert
   */
  export type RoundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * The filter to search for the Round to update in case it exists.
     */
    where: RoundWhereUniqueInput
    /**
     * In case the Round found by the `where` argument doesn't exist, create a new Round with this data.
     */
    create: XOR<RoundCreateInput, RoundUncheckedCreateInput>
    /**
     * In case the Round was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundUpdateInput, RoundUncheckedUpdateInput>
  }

  /**
   * Round delete
   */
  export type RoundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
    /**
     * Filter which Round to delete.
     */
    where: RoundWhereUniqueInput
  }

  /**
   * Round deleteMany
   */
  export type RoundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rounds to delete
     */
    where?: RoundWhereInput
    /**
     * Limit how many Rounds to delete.
     */
    limit?: number
  }

  /**
   * Round.assignments
   */
  export type Round$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    where?: RoundAssignmentWhereInput
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    cursor?: RoundAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoundAssignmentScalarFieldEnum | RoundAssignmentScalarFieldEnum[]
  }

  /**
   * Round.Score
   */
  export type Round$ScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    cursor?: ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Round without action
   */
  export type RoundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Round
     */
    select?: RoundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Round
     */
    omit?: RoundOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundInclude<ExtArgs> | null
  }


  /**
   * Model RoundAssignment
   */

  export type AggregateRoundAssignment = {
    _count: RoundAssignmentCountAggregateOutputType | null
    _avg: RoundAssignmentAvgAggregateOutputType | null
    _sum: RoundAssignmentSumAggregateOutputType | null
    _min: RoundAssignmentMinAggregateOutputType | null
    _max: RoundAssignmentMaxAggregateOutputType | null
  }

  export type RoundAssignmentAvgAggregateOutputType = {
    id: number | null
    roundId: number | null
    roomId: number | null
    judgeId: number | null
  }

  export type RoundAssignmentSumAggregateOutputType = {
    id: number | null
    roundId: number | null
    roomId: number | null
    judgeId: number | null
  }

  export type RoundAssignmentMinAggregateOutputType = {
    id: number | null
    roundId: number | null
    roomId: number | null
    judgeId: number | null
  }

  export type RoundAssignmentMaxAggregateOutputType = {
    id: number | null
    roundId: number | null
    roomId: number | null
    judgeId: number | null
  }

  export type RoundAssignmentCountAggregateOutputType = {
    id: number
    roundId: number
    roomId: number
    judgeId: number
    _all: number
  }


  export type RoundAssignmentAvgAggregateInputType = {
    id?: true
    roundId?: true
    roomId?: true
    judgeId?: true
  }

  export type RoundAssignmentSumAggregateInputType = {
    id?: true
    roundId?: true
    roomId?: true
    judgeId?: true
  }

  export type RoundAssignmentMinAggregateInputType = {
    id?: true
    roundId?: true
    roomId?: true
    judgeId?: true
  }

  export type RoundAssignmentMaxAggregateInputType = {
    id?: true
    roundId?: true
    roomId?: true
    judgeId?: true
  }

  export type RoundAssignmentCountAggregateInputType = {
    id?: true
    roundId?: true
    roomId?: true
    judgeId?: true
    _all?: true
  }

  export type RoundAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoundAssignment to aggregate.
     */
    where?: RoundAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundAssignments to fetch.
     */
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoundAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoundAssignments
    **/
    _count?: true | RoundAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoundAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoundAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoundAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoundAssignmentMaxAggregateInputType
  }

  export type GetRoundAssignmentAggregateType<T extends RoundAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRoundAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoundAssignment[P]>
      : GetScalarType<T[P], AggregateRoundAssignment[P]>
  }




  export type RoundAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoundAssignmentWhereInput
    orderBy?: RoundAssignmentOrderByWithAggregationInput | RoundAssignmentOrderByWithAggregationInput[]
    by: RoundAssignmentScalarFieldEnum[] | RoundAssignmentScalarFieldEnum
    having?: RoundAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoundAssignmentCountAggregateInputType | true
    _avg?: RoundAssignmentAvgAggregateInputType
    _sum?: RoundAssignmentSumAggregateInputType
    _min?: RoundAssignmentMinAggregateInputType
    _max?: RoundAssignmentMaxAggregateInputType
  }

  export type RoundAssignmentGroupByOutputType = {
    id: number
    roundId: number
    roomId: number
    judgeId: number | null
    _count: RoundAssignmentCountAggregateOutputType | null
    _avg: RoundAssignmentAvgAggregateOutputType | null
    _sum: RoundAssignmentSumAggregateOutputType | null
    _min: RoundAssignmentMinAggregateOutputType | null
    _max: RoundAssignmentMaxAggregateOutputType | null
  }

  type GetRoundAssignmentGroupByPayload<T extends RoundAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoundAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoundAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoundAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], RoundAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type RoundAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    roomId?: boolean
    judgeId?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    judge?: boolean | RoundAssignment$judgeArgs<ExtArgs>
    matchResults?: boolean | RoundAssignment$matchResultsArgs<ExtArgs>
    teamAssignments?: boolean | RoundAssignment$teamAssignmentsArgs<ExtArgs>
    _count?: boolean | RoundAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roundAssignment"]>

  export type RoundAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    roomId?: boolean
    judgeId?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    judge?: boolean | RoundAssignment$judgeArgs<ExtArgs>
  }, ExtArgs["result"]["roundAssignment"]>

  export type RoundAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundId?: boolean
    roomId?: boolean
    judgeId?: boolean
    round?: boolean | RoundDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    judge?: boolean | RoundAssignment$judgeArgs<ExtArgs>
  }, ExtArgs["result"]["roundAssignment"]>

  export type RoundAssignmentSelectScalar = {
    id?: boolean
    roundId?: boolean
    roomId?: boolean
    judgeId?: boolean
  }

  export type RoundAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roundId" | "roomId" | "judgeId", ExtArgs["result"]["roundAssignment"]>
  export type RoundAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    judge?: boolean | RoundAssignment$judgeArgs<ExtArgs>
    matchResults?: boolean | RoundAssignment$matchResultsArgs<ExtArgs>
    teamAssignments?: boolean | RoundAssignment$teamAssignmentsArgs<ExtArgs>
    _count?: boolean | RoundAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoundAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    judge?: boolean | RoundAssignment$judgeArgs<ExtArgs>
  }
  export type RoundAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    round?: boolean | RoundDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    judge?: boolean | RoundAssignment$judgeArgs<ExtArgs>
  }

  export type $RoundAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoundAssignment"
    objects: {
      round: Prisma.$RoundPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
      judge: Prisma.$JudgePayload<ExtArgs> | null
      matchResults: Prisma.$MatchResultPayload<ExtArgs>[]
      teamAssignments: Prisma.$TeamAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundId: number
      roomId: number
      judgeId: number | null
    }, ExtArgs["result"]["roundAssignment"]>
    composites: {}
  }

  type RoundAssignmentGetPayload<S extends boolean | null | undefined | RoundAssignmentDefaultArgs> = $Result.GetResult<Prisma.$RoundAssignmentPayload, S>

  type RoundAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoundAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoundAssignmentCountAggregateInputType | true
    }

  export interface RoundAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoundAssignment'], meta: { name: 'RoundAssignment' } }
    /**
     * Find zero or one RoundAssignment that matches the filter.
     * @param {RoundAssignmentFindUniqueArgs} args - Arguments to find a RoundAssignment
     * @example
     * // Get one RoundAssignment
     * const roundAssignment = await prisma.roundAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoundAssignmentFindUniqueArgs>(args: SelectSubset<T, RoundAssignmentFindUniqueArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoundAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoundAssignmentFindUniqueOrThrowArgs} args - Arguments to find a RoundAssignment
     * @example
     * // Get one RoundAssignment
     * const roundAssignment = await prisma.roundAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoundAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RoundAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoundAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentFindFirstArgs} args - Arguments to find a RoundAssignment
     * @example
     * // Get one RoundAssignment
     * const roundAssignment = await prisma.roundAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoundAssignmentFindFirstArgs>(args?: SelectSubset<T, RoundAssignmentFindFirstArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoundAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentFindFirstOrThrowArgs} args - Arguments to find a RoundAssignment
     * @example
     * // Get one RoundAssignment
     * const roundAssignment = await prisma.roundAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoundAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RoundAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoundAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoundAssignments
     * const roundAssignments = await prisma.roundAssignment.findMany()
     * 
     * // Get first 10 RoundAssignments
     * const roundAssignments = await prisma.roundAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roundAssignmentWithIdOnly = await prisma.roundAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoundAssignmentFindManyArgs>(args?: SelectSubset<T, RoundAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoundAssignment.
     * @param {RoundAssignmentCreateArgs} args - Arguments to create a RoundAssignment.
     * @example
     * // Create one RoundAssignment
     * const RoundAssignment = await prisma.roundAssignment.create({
     *   data: {
     *     // ... data to create a RoundAssignment
     *   }
     * })
     * 
     */
    create<T extends RoundAssignmentCreateArgs>(args: SelectSubset<T, RoundAssignmentCreateArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoundAssignments.
     * @param {RoundAssignmentCreateManyArgs} args - Arguments to create many RoundAssignments.
     * @example
     * // Create many RoundAssignments
     * const roundAssignment = await prisma.roundAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoundAssignmentCreateManyArgs>(args?: SelectSubset<T, RoundAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoundAssignments and returns the data saved in the database.
     * @param {RoundAssignmentCreateManyAndReturnArgs} args - Arguments to create many RoundAssignments.
     * @example
     * // Create many RoundAssignments
     * const roundAssignment = await prisma.roundAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoundAssignments and only return the `id`
     * const roundAssignmentWithIdOnly = await prisma.roundAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoundAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RoundAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoundAssignment.
     * @param {RoundAssignmentDeleteArgs} args - Arguments to delete one RoundAssignment.
     * @example
     * // Delete one RoundAssignment
     * const RoundAssignment = await prisma.roundAssignment.delete({
     *   where: {
     *     // ... filter to delete one RoundAssignment
     *   }
     * })
     * 
     */
    delete<T extends RoundAssignmentDeleteArgs>(args: SelectSubset<T, RoundAssignmentDeleteArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoundAssignment.
     * @param {RoundAssignmentUpdateArgs} args - Arguments to update one RoundAssignment.
     * @example
     * // Update one RoundAssignment
     * const roundAssignment = await prisma.roundAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoundAssignmentUpdateArgs>(args: SelectSubset<T, RoundAssignmentUpdateArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoundAssignments.
     * @param {RoundAssignmentDeleteManyArgs} args - Arguments to filter RoundAssignments to delete.
     * @example
     * // Delete a few RoundAssignments
     * const { count } = await prisma.roundAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoundAssignmentDeleteManyArgs>(args?: SelectSubset<T, RoundAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoundAssignments
     * const roundAssignment = await prisma.roundAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoundAssignmentUpdateManyArgs>(args: SelectSubset<T, RoundAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoundAssignments and returns the data updated in the database.
     * @param {RoundAssignmentUpdateManyAndReturnArgs} args - Arguments to update many RoundAssignments.
     * @example
     * // Update many RoundAssignments
     * const roundAssignment = await prisma.roundAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoundAssignments and only return the `id`
     * const roundAssignmentWithIdOnly = await prisma.roundAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoundAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, RoundAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoundAssignment.
     * @param {RoundAssignmentUpsertArgs} args - Arguments to update or create a RoundAssignment.
     * @example
     * // Update or create a RoundAssignment
     * const roundAssignment = await prisma.roundAssignment.upsert({
     *   create: {
     *     // ... data to create a RoundAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoundAssignment we want to update
     *   }
     * })
     */
    upsert<T extends RoundAssignmentUpsertArgs>(args: SelectSubset<T, RoundAssignmentUpsertArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoundAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentCountArgs} args - Arguments to filter RoundAssignments to count.
     * @example
     * // Count the number of RoundAssignments
     * const count = await prisma.roundAssignment.count({
     *   where: {
     *     // ... the filter for the RoundAssignments we want to count
     *   }
     * })
    **/
    count<T extends RoundAssignmentCountArgs>(
      args?: Subset<T, RoundAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoundAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoundAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoundAssignmentAggregateArgs>(args: Subset<T, RoundAssignmentAggregateArgs>): Prisma.PrismaPromise<GetRoundAssignmentAggregateType<T>>

    /**
     * Group by RoundAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoundAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoundAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoundAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: RoundAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoundAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoundAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoundAssignment model
   */
  readonly fields: RoundAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoundAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoundAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    round<T extends RoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundDefaultArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    judge<T extends RoundAssignment$judgeArgs<ExtArgs> = {}>(args?: Subset<T, RoundAssignment$judgeArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    matchResults<T extends RoundAssignment$matchResultsArgs<ExtArgs> = {}>(args?: Subset<T, RoundAssignment$matchResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamAssignments<T extends RoundAssignment$teamAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, RoundAssignment$teamAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoundAssignment model
   */
  interface RoundAssignmentFieldRefs {
    readonly id: FieldRef<"RoundAssignment", 'Int'>
    readonly roundId: FieldRef<"RoundAssignment", 'Int'>
    readonly roomId: FieldRef<"RoundAssignment", 'Int'>
    readonly judgeId: FieldRef<"RoundAssignment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoundAssignment findUnique
   */
  export type RoundAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoundAssignment to fetch.
     */
    where: RoundAssignmentWhereUniqueInput
  }

  /**
   * RoundAssignment findUniqueOrThrow
   */
  export type RoundAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoundAssignment to fetch.
     */
    where: RoundAssignmentWhereUniqueInput
  }

  /**
   * RoundAssignment findFirst
   */
  export type RoundAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoundAssignment to fetch.
     */
    where?: RoundAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundAssignments to fetch.
     */
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoundAssignments.
     */
    cursor?: RoundAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoundAssignments.
     */
    distinct?: RoundAssignmentScalarFieldEnum | RoundAssignmentScalarFieldEnum[]
  }

  /**
   * RoundAssignment findFirstOrThrow
   */
  export type RoundAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoundAssignment to fetch.
     */
    where?: RoundAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundAssignments to fetch.
     */
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoundAssignments.
     */
    cursor?: RoundAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoundAssignments.
     */
    distinct?: RoundAssignmentScalarFieldEnum | RoundAssignmentScalarFieldEnum[]
  }

  /**
   * RoundAssignment findMany
   */
  export type RoundAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoundAssignments to fetch.
     */
    where?: RoundAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoundAssignments to fetch.
     */
    orderBy?: RoundAssignmentOrderByWithRelationInput | RoundAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoundAssignments.
     */
    cursor?: RoundAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoundAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoundAssignments.
     */
    skip?: number
    distinct?: RoundAssignmentScalarFieldEnum | RoundAssignmentScalarFieldEnum[]
  }

  /**
   * RoundAssignment create
   */
  export type RoundAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RoundAssignment.
     */
    data: XOR<RoundAssignmentCreateInput, RoundAssignmentUncheckedCreateInput>
  }

  /**
   * RoundAssignment createMany
   */
  export type RoundAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoundAssignments.
     */
    data: RoundAssignmentCreateManyInput | RoundAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoundAssignment createManyAndReturn
   */
  export type RoundAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many RoundAssignments.
     */
    data: RoundAssignmentCreateManyInput | RoundAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoundAssignment update
   */
  export type RoundAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RoundAssignment.
     */
    data: XOR<RoundAssignmentUpdateInput, RoundAssignmentUncheckedUpdateInput>
    /**
     * Choose, which RoundAssignment to update.
     */
    where: RoundAssignmentWhereUniqueInput
  }

  /**
   * RoundAssignment updateMany
   */
  export type RoundAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoundAssignments.
     */
    data: XOR<RoundAssignmentUpdateManyMutationInput, RoundAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoundAssignments to update
     */
    where?: RoundAssignmentWhereInput
    /**
     * Limit how many RoundAssignments to update.
     */
    limit?: number
  }

  /**
   * RoundAssignment updateManyAndReturn
   */
  export type RoundAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update RoundAssignments.
     */
    data: XOR<RoundAssignmentUpdateManyMutationInput, RoundAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoundAssignments to update
     */
    where?: RoundAssignmentWhereInput
    /**
     * Limit how many RoundAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoundAssignment upsert
   */
  export type RoundAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RoundAssignment to update in case it exists.
     */
    where: RoundAssignmentWhereUniqueInput
    /**
     * In case the RoundAssignment found by the `where` argument doesn't exist, create a new RoundAssignment with this data.
     */
    create: XOR<RoundAssignmentCreateInput, RoundAssignmentUncheckedCreateInput>
    /**
     * In case the RoundAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoundAssignmentUpdateInput, RoundAssignmentUncheckedUpdateInput>
  }

  /**
   * RoundAssignment delete
   */
  export type RoundAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
    /**
     * Filter which RoundAssignment to delete.
     */
    where: RoundAssignmentWhereUniqueInput
  }

  /**
   * RoundAssignment deleteMany
   */
  export type RoundAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoundAssignments to delete
     */
    where?: RoundAssignmentWhereInput
    /**
     * Limit how many RoundAssignments to delete.
     */
    limit?: number
  }

  /**
   * RoundAssignment.judge
   */
  export type RoundAssignment$judgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Judge
     */
    select?: JudgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Judge
     */
    omit?: JudgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JudgeInclude<ExtArgs> | null
    where?: JudgeWhereInput
  }

  /**
   * RoundAssignment.matchResults
   */
  export type RoundAssignment$matchResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    where?: MatchResultWhereInput
    orderBy?: MatchResultOrderByWithRelationInput | MatchResultOrderByWithRelationInput[]
    cursor?: MatchResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchResultScalarFieldEnum | MatchResultScalarFieldEnum[]
  }

  /**
   * RoundAssignment.teamAssignments
   */
  export type RoundAssignment$teamAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    where?: TeamAssignmentWhereInput
    orderBy?: TeamAssignmentOrderByWithRelationInput | TeamAssignmentOrderByWithRelationInput[]
    cursor?: TeamAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamAssignmentScalarFieldEnum | TeamAssignmentScalarFieldEnum[]
  }

  /**
   * RoundAssignment without action
   */
  export type RoundAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoundAssignment
     */
    select?: RoundAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoundAssignment
     */
    omit?: RoundAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoundAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Score
   */

  export type AggregateScore = {
    _count: ScoreCountAggregateOutputType | null
    _avg: ScoreAvgAggregateOutputType | null
    _sum: ScoreSumAggregateOutputType | null
    _min: ScoreMinAggregateOutputType | null
    _max: ScoreMaxAggregateOutputType | null
  }

  export type ScoreAvgAggregateOutputType = {
    id: number | null
    judgeId: number | null
    roundId: number | null
    teamId: number | null
    participantId: number | null
    value: number | null
  }

  export type ScoreSumAggregateOutputType = {
    id: number | null
    judgeId: number | null
    roundId: number | null
    teamId: number | null
    participantId: number | null
    value: number | null
  }

  export type ScoreMinAggregateOutputType = {
    id: number | null
    judgeId: number | null
    roundId: number | null
    teamId: number | null
    participantId: number | null
    scoreType: $Enums.ScoreType | null
    value: number | null
  }

  export type ScoreMaxAggregateOutputType = {
    id: number | null
    judgeId: number | null
    roundId: number | null
    teamId: number | null
    participantId: number | null
    scoreType: $Enums.ScoreType | null
    value: number | null
  }

  export type ScoreCountAggregateOutputType = {
    id: number
    judgeId: number
    roundId: number
    teamId: number
    participantId: number
    scoreType: number
    value: number
    _all: number
  }


  export type ScoreAvgAggregateInputType = {
    id?: true
    judgeId?: true
    roundId?: true
    teamId?: true
    participantId?: true
    value?: true
  }

  export type ScoreSumAggregateInputType = {
    id?: true
    judgeId?: true
    roundId?: true
    teamId?: true
    participantId?: true
    value?: true
  }

  export type ScoreMinAggregateInputType = {
    id?: true
    judgeId?: true
    roundId?: true
    teamId?: true
    participantId?: true
    scoreType?: true
    value?: true
  }

  export type ScoreMaxAggregateInputType = {
    id?: true
    judgeId?: true
    roundId?: true
    teamId?: true
    participantId?: true
    scoreType?: true
    value?: true
  }

  export type ScoreCountAggregateInputType = {
    id?: true
    judgeId?: true
    roundId?: true
    teamId?: true
    participantId?: true
    scoreType?: true
    value?: true
    _all?: true
  }

  export type ScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Score to aggregate.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Scores
    **/
    _count?: true | ScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScoreMaxAggregateInputType
  }

  export type GetScoreAggregateType<T extends ScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScore[P]>
      : GetScalarType<T[P], AggregateScore[P]>
  }




  export type ScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScoreWhereInput
    orderBy?: ScoreOrderByWithAggregationInput | ScoreOrderByWithAggregationInput[]
    by: ScoreScalarFieldEnum[] | ScoreScalarFieldEnum
    having?: ScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScoreCountAggregateInputType | true
    _avg?: ScoreAvgAggregateInputType
    _sum?: ScoreSumAggregateInputType
    _min?: ScoreMinAggregateInputType
    _max?: ScoreMaxAggregateInputType
  }

  export type ScoreGroupByOutputType = {
    id: number
    judgeId: number
    roundId: number
    teamId: number
    participantId: number | null
    scoreType: $Enums.ScoreType
    value: number
    _count: ScoreCountAggregateOutputType | null
    _avg: ScoreAvgAggregateOutputType | null
    _sum: ScoreSumAggregateOutputType | null
    _min: ScoreMinAggregateOutputType | null
    _max: ScoreMaxAggregateOutputType | null
  }

  type GetScoreGroupByPayload<T extends ScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ScoreGroupByOutputType[P]>
        }
      >
    >


  export type ScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    judgeId?: boolean
    roundId?: boolean
    teamId?: boolean
    participantId?: boolean
    scoreType?: boolean
    value?: boolean
    judge?: boolean | JudgeDefaultArgs<ExtArgs>
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    participant?: boolean | Score$participantArgs<ExtArgs>
  }, ExtArgs["result"]["score"]>

  export type ScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    judgeId?: boolean
    roundId?: boolean
    teamId?: boolean
    participantId?: boolean
    scoreType?: boolean
    value?: boolean
    judge?: boolean | JudgeDefaultArgs<ExtArgs>
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    participant?: boolean | Score$participantArgs<ExtArgs>
  }, ExtArgs["result"]["score"]>

  export type ScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    judgeId?: boolean
    roundId?: boolean
    teamId?: boolean
    participantId?: boolean
    scoreType?: boolean
    value?: boolean
    judge?: boolean | JudgeDefaultArgs<ExtArgs>
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    participant?: boolean | Score$participantArgs<ExtArgs>
  }, ExtArgs["result"]["score"]>

  export type ScoreSelectScalar = {
    id?: boolean
    judgeId?: boolean
    roundId?: boolean
    teamId?: boolean
    participantId?: boolean
    scoreType?: boolean
    value?: boolean
  }

  export type ScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "judgeId" | "roundId" | "teamId" | "participantId" | "scoreType" | "value", ExtArgs["result"]["score"]>
  export type ScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judge?: boolean | JudgeDefaultArgs<ExtArgs>
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    participant?: boolean | Score$participantArgs<ExtArgs>
  }
  export type ScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judge?: boolean | JudgeDefaultArgs<ExtArgs>
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    participant?: boolean | Score$participantArgs<ExtArgs>
  }
  export type ScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    judge?: boolean | JudgeDefaultArgs<ExtArgs>
    round?: boolean | RoundDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    participant?: boolean | Score$participantArgs<ExtArgs>
  }

  export type $ScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Score"
    objects: {
      judge: Prisma.$JudgePayload<ExtArgs>
      round: Prisma.$RoundPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      participant: Prisma.$ParticipantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      judgeId: number
      roundId: number
      teamId: number
      participantId: number | null
      scoreType: $Enums.ScoreType
      value: number
    }, ExtArgs["result"]["score"]>
    composites: {}
  }

  type ScoreGetPayload<S extends boolean | null | undefined | ScoreDefaultArgs> = $Result.GetResult<Prisma.$ScorePayload, S>

  type ScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScoreCountAggregateInputType | true
    }

  export interface ScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Score'], meta: { name: 'Score' } }
    /**
     * Find zero or one Score that matches the filter.
     * @param {ScoreFindUniqueArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScoreFindUniqueArgs>(args: SelectSubset<T, ScoreFindUniqueArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Score that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScoreFindUniqueOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Score that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScoreFindFirstArgs>(args?: SelectSubset<T, ScoreFindFirstArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Score that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindFirstOrThrowArgs} args - Arguments to find a Score
     * @example
     * // Get one Score
     * const score = await prisma.score.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scores
     * const scores = await prisma.score.findMany()
     * 
     * // Get first 10 Scores
     * const scores = await prisma.score.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scoreWithIdOnly = await prisma.score.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScoreFindManyArgs>(args?: SelectSubset<T, ScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Score.
     * @param {ScoreCreateArgs} args - Arguments to create a Score.
     * @example
     * // Create one Score
     * const Score = await prisma.score.create({
     *   data: {
     *     // ... data to create a Score
     *   }
     * })
     * 
     */
    create<T extends ScoreCreateArgs>(args: SelectSubset<T, ScoreCreateArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scores.
     * @param {ScoreCreateManyArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScoreCreateManyArgs>(args?: SelectSubset<T, ScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scores and returns the data saved in the database.
     * @param {ScoreCreateManyAndReturnArgs} args - Arguments to create many Scores.
     * @example
     * // Create many Scores
     * const score = await prisma.score.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scores and only return the `id`
     * const scoreWithIdOnly = await prisma.score.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Score.
     * @param {ScoreDeleteArgs} args - Arguments to delete one Score.
     * @example
     * // Delete one Score
     * const Score = await prisma.score.delete({
     *   where: {
     *     // ... filter to delete one Score
     *   }
     * })
     * 
     */
    delete<T extends ScoreDeleteArgs>(args: SelectSubset<T, ScoreDeleteArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Score.
     * @param {ScoreUpdateArgs} args - Arguments to update one Score.
     * @example
     * // Update one Score
     * const score = await prisma.score.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScoreUpdateArgs>(args: SelectSubset<T, ScoreUpdateArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scores.
     * @param {ScoreDeleteManyArgs} args - Arguments to filter Scores to delete.
     * @example
     * // Delete a few Scores
     * const { count } = await prisma.score.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScoreDeleteManyArgs>(args?: SelectSubset<T, ScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scores
     * const score = await prisma.score.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScoreUpdateManyArgs>(args: SelectSubset<T, ScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scores and returns the data updated in the database.
     * @param {ScoreUpdateManyAndReturnArgs} args - Arguments to update many Scores.
     * @example
     * // Update many Scores
     * const score = await prisma.score.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scores and only return the `id`
     * const scoreWithIdOnly = await prisma.score.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Score.
     * @param {ScoreUpsertArgs} args - Arguments to update or create a Score.
     * @example
     * // Update or create a Score
     * const score = await prisma.score.upsert({
     *   create: {
     *     // ... data to create a Score
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Score we want to update
     *   }
     * })
     */
    upsert<T extends ScoreUpsertArgs>(args: SelectSubset<T, ScoreUpsertArgs<ExtArgs>>): Prisma__ScoreClient<$Result.GetResult<Prisma.$ScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreCountArgs} args - Arguments to filter Scores to count.
     * @example
     * // Count the number of Scores
     * const count = await prisma.score.count({
     *   where: {
     *     // ... the filter for the Scores we want to count
     *   }
     * })
    **/
    count<T extends ScoreCountArgs>(
      args?: Subset<T, ScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScoreAggregateArgs>(args: Subset<T, ScoreAggregateArgs>): Prisma.PrismaPromise<GetScoreAggregateType<T>>

    /**
     * Group by Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScoreGroupByArgs['orderBy'] }
        : { orderBy?: ScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Score model
   */
  readonly fields: ScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Score.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    judge<T extends JudgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JudgeDefaultArgs<ExtArgs>>): Prisma__JudgeClient<$Result.GetResult<Prisma.$JudgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    round<T extends RoundDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundDefaultArgs<ExtArgs>>): Prisma__RoundClient<$Result.GetResult<Prisma.$RoundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participant<T extends Score$participantArgs<ExtArgs> = {}>(args?: Subset<T, Score$participantArgs<ExtArgs>>): Prisma__ParticipantClient<$Result.GetResult<Prisma.$ParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Score model
   */
  interface ScoreFieldRefs {
    readonly id: FieldRef<"Score", 'Int'>
    readonly judgeId: FieldRef<"Score", 'Int'>
    readonly roundId: FieldRef<"Score", 'Int'>
    readonly teamId: FieldRef<"Score", 'Int'>
    readonly participantId: FieldRef<"Score", 'Int'>
    readonly scoreType: FieldRef<"Score", 'ScoreType'>
    readonly value: FieldRef<"Score", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Score findUnique
   */
  export type ScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput
  }

  /**
   * Score findUniqueOrThrow
   */
  export type ScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where: ScoreWhereUniqueInput
  }

  /**
   * Score findFirst
   */
  export type ScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Score findFirstOrThrow
   */
  export type ScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Score to fetch.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Scores.
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Scores.
     */
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Score findMany
   */
  export type ScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Scores to fetch.
     */
    where?: ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Scores to fetch.
     */
    orderBy?: ScoreOrderByWithRelationInput | ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Scores.
     */
    cursor?: ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Scores.
     */
    skip?: number
    distinct?: ScoreScalarFieldEnum | ScoreScalarFieldEnum[]
  }

  /**
   * Score create
   */
  export type ScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Score.
     */
    data: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>
  }

  /**
   * Score createMany
   */
  export type ScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Score createManyAndReturn
   */
  export type ScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * The data used to create many Scores.
     */
    data: ScoreCreateManyInput | ScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Score update
   */
  export type ScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Score.
     */
    data: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>
    /**
     * Choose, which Score to update.
     */
    where: ScoreWhereUniqueInput
  }

  /**
   * Score updateMany
   */
  export type ScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Scores.
     */
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyInput>
    /**
     * Filter which Scores to update
     */
    where?: ScoreWhereInput
    /**
     * Limit how many Scores to update.
     */
    limit?: number
  }

  /**
   * Score updateManyAndReturn
   */
  export type ScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * The data used to update Scores.
     */
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyInput>
    /**
     * Filter which Scores to update
     */
    where?: ScoreWhereInput
    /**
     * Limit how many Scores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Score upsert
   */
  export type ScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Score to update in case it exists.
     */
    where: ScoreWhereUniqueInput
    /**
     * In case the Score found by the `where` argument doesn't exist, create a new Score with this data.
     */
    create: XOR<ScoreCreateInput, ScoreUncheckedCreateInput>
    /**
     * In case the Score was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScoreUpdateInput, ScoreUncheckedUpdateInput>
  }

  /**
   * Score delete
   */
  export type ScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
    /**
     * Filter which Score to delete.
     */
    where: ScoreWhereUniqueInput
  }

  /**
   * Score deleteMany
   */
  export type ScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Scores to delete
     */
    where?: ScoreWhereInput
    /**
     * Limit how many Scores to delete.
     */
    limit?: number
  }

  /**
   * Score.participant
   */
  export type Score$participantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participant
     */
    select?: ParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participant
     */
    omit?: ParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipantInclude<ExtArgs> | null
    where?: ParticipantWhereInput
  }

  /**
   * Score without action
   */
  export type ScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Score
     */
    select?: ScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Score
     */
    omit?: ScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScoreInclude<ExtArgs> | null
  }


  /**
   * Model MatchResult
   */

  export type AggregateMatchResult = {
    _count: MatchResultCountAggregateOutputType | null
    _avg: MatchResultAvgAggregateOutputType | null
    _sum: MatchResultSumAggregateOutputType | null
    _min: MatchResultMinAggregateOutputType | null
    _max: MatchResultMaxAggregateOutputType | null
  }

  export type MatchResultAvgAggregateOutputType = {
    id: number | null
    roundAssignmentId: number | null
    teamId: number | null
    rank: number | null
    points: number | null
  }

  export type MatchResultSumAggregateOutputType = {
    id: number | null
    roundAssignmentId: number | null
    teamId: number | null
    rank: number | null
    points: number | null
  }

  export type MatchResultMinAggregateOutputType = {
    id: number | null
    roundAssignmentId: number | null
    teamId: number | null
    rank: number | null
    points: number | null
  }

  export type MatchResultMaxAggregateOutputType = {
    id: number | null
    roundAssignmentId: number | null
    teamId: number | null
    rank: number | null
    points: number | null
  }

  export type MatchResultCountAggregateOutputType = {
    id: number
    roundAssignmentId: number
    teamId: number
    rank: number
    points: number
    _all: number
  }


  export type MatchResultAvgAggregateInputType = {
    id?: true
    roundAssignmentId?: true
    teamId?: true
    rank?: true
    points?: true
  }

  export type MatchResultSumAggregateInputType = {
    id?: true
    roundAssignmentId?: true
    teamId?: true
    rank?: true
    points?: true
  }

  export type MatchResultMinAggregateInputType = {
    id?: true
    roundAssignmentId?: true
    teamId?: true
    rank?: true
    points?: true
  }

  export type MatchResultMaxAggregateInputType = {
    id?: true
    roundAssignmentId?: true
    teamId?: true
    rank?: true
    points?: true
  }

  export type MatchResultCountAggregateInputType = {
    id?: true
    roundAssignmentId?: true
    teamId?: true
    rank?: true
    points?: true
    _all?: true
  }

  export type MatchResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchResult to aggregate.
     */
    where?: MatchResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchResults to fetch.
     */
    orderBy?: MatchResultOrderByWithRelationInput | MatchResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchResults
    **/
    _count?: true | MatchResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchResultMaxAggregateInputType
  }

  export type GetMatchResultAggregateType<T extends MatchResultAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchResult[P]>
      : GetScalarType<T[P], AggregateMatchResult[P]>
  }




  export type MatchResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchResultWhereInput
    orderBy?: MatchResultOrderByWithAggregationInput | MatchResultOrderByWithAggregationInput[]
    by: MatchResultScalarFieldEnum[] | MatchResultScalarFieldEnum
    having?: MatchResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchResultCountAggregateInputType | true
    _avg?: MatchResultAvgAggregateInputType
    _sum?: MatchResultSumAggregateInputType
    _min?: MatchResultMinAggregateInputType
    _max?: MatchResultMaxAggregateInputType
  }

  export type MatchResultGroupByOutputType = {
    id: number
    roundAssignmentId: number
    teamId: number
    rank: number
    points: number
    _count: MatchResultCountAggregateOutputType | null
    _avg: MatchResultAvgAggregateOutputType | null
    _sum: MatchResultSumAggregateOutputType | null
    _min: MatchResultMinAggregateOutputType | null
    _max: MatchResultMaxAggregateOutputType | null
  }

  type GetMatchResultGroupByPayload<T extends MatchResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchResultGroupByOutputType[P]>
            : GetScalarType<T[P], MatchResultGroupByOutputType[P]>
        }
      >
    >


  export type MatchResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundAssignmentId?: boolean
    teamId?: boolean
    rank?: boolean
    points?: boolean
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchResult"]>

  export type MatchResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundAssignmentId?: boolean
    teamId?: boolean
    rank?: boolean
    points?: boolean
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchResult"]>

  export type MatchResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roundAssignmentId?: boolean
    teamId?: boolean
    rank?: boolean
    points?: boolean
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchResult"]>

  export type MatchResultSelectScalar = {
    id?: boolean
    roundAssignmentId?: boolean
    teamId?: boolean
    rank?: boolean
    points?: boolean
  }

  export type MatchResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roundAssignmentId" | "teamId" | "rank" | "points", ExtArgs["result"]["matchResult"]>
  export type MatchResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type MatchResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type MatchResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $MatchResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchResult"
    objects: {
      roundAssignment: Prisma.$RoundAssignmentPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roundAssignmentId: number
      teamId: number
      rank: number
      points: number
    }, ExtArgs["result"]["matchResult"]>
    composites: {}
  }

  type MatchResultGetPayload<S extends boolean | null | undefined | MatchResultDefaultArgs> = $Result.GetResult<Prisma.$MatchResultPayload, S>

  type MatchResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchResultCountAggregateInputType | true
    }

  export interface MatchResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchResult'], meta: { name: 'MatchResult' } }
    /**
     * Find zero or one MatchResult that matches the filter.
     * @param {MatchResultFindUniqueArgs} args - Arguments to find a MatchResult
     * @example
     * // Get one MatchResult
     * const matchResult = await prisma.matchResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchResultFindUniqueArgs>(args: SelectSubset<T, MatchResultFindUniqueArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchResultFindUniqueOrThrowArgs} args - Arguments to find a MatchResult
     * @example
     * // Get one MatchResult
     * const matchResult = await prisma.matchResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchResultFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultFindFirstArgs} args - Arguments to find a MatchResult
     * @example
     * // Get one MatchResult
     * const matchResult = await prisma.matchResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchResultFindFirstArgs>(args?: SelectSubset<T, MatchResultFindFirstArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultFindFirstOrThrowArgs} args - Arguments to find a MatchResult
     * @example
     * // Get one MatchResult
     * const matchResult = await prisma.matchResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchResultFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchResults
     * const matchResults = await prisma.matchResult.findMany()
     * 
     * // Get first 10 MatchResults
     * const matchResults = await prisma.matchResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchResultWithIdOnly = await prisma.matchResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchResultFindManyArgs>(args?: SelectSubset<T, MatchResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchResult.
     * @param {MatchResultCreateArgs} args - Arguments to create a MatchResult.
     * @example
     * // Create one MatchResult
     * const MatchResult = await prisma.matchResult.create({
     *   data: {
     *     // ... data to create a MatchResult
     *   }
     * })
     * 
     */
    create<T extends MatchResultCreateArgs>(args: SelectSubset<T, MatchResultCreateArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchResults.
     * @param {MatchResultCreateManyArgs} args - Arguments to create many MatchResults.
     * @example
     * // Create many MatchResults
     * const matchResult = await prisma.matchResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchResultCreateManyArgs>(args?: SelectSubset<T, MatchResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchResults and returns the data saved in the database.
     * @param {MatchResultCreateManyAndReturnArgs} args - Arguments to create many MatchResults.
     * @example
     * // Create many MatchResults
     * const matchResult = await prisma.matchResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchResults and only return the `id`
     * const matchResultWithIdOnly = await prisma.matchResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchResultCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchResult.
     * @param {MatchResultDeleteArgs} args - Arguments to delete one MatchResult.
     * @example
     * // Delete one MatchResult
     * const MatchResult = await prisma.matchResult.delete({
     *   where: {
     *     // ... filter to delete one MatchResult
     *   }
     * })
     * 
     */
    delete<T extends MatchResultDeleteArgs>(args: SelectSubset<T, MatchResultDeleteArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchResult.
     * @param {MatchResultUpdateArgs} args - Arguments to update one MatchResult.
     * @example
     * // Update one MatchResult
     * const matchResult = await prisma.matchResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchResultUpdateArgs>(args: SelectSubset<T, MatchResultUpdateArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchResults.
     * @param {MatchResultDeleteManyArgs} args - Arguments to filter MatchResults to delete.
     * @example
     * // Delete a few MatchResults
     * const { count } = await prisma.matchResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchResultDeleteManyArgs>(args?: SelectSubset<T, MatchResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchResults
     * const matchResult = await prisma.matchResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchResultUpdateManyArgs>(args: SelectSubset<T, MatchResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchResults and returns the data updated in the database.
     * @param {MatchResultUpdateManyAndReturnArgs} args - Arguments to update many MatchResults.
     * @example
     * // Update many MatchResults
     * const matchResult = await prisma.matchResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchResults and only return the `id`
     * const matchResultWithIdOnly = await prisma.matchResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchResultUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchResult.
     * @param {MatchResultUpsertArgs} args - Arguments to update or create a MatchResult.
     * @example
     * // Update or create a MatchResult
     * const matchResult = await prisma.matchResult.upsert({
     *   create: {
     *     // ... data to create a MatchResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchResult we want to update
     *   }
     * })
     */
    upsert<T extends MatchResultUpsertArgs>(args: SelectSubset<T, MatchResultUpsertArgs<ExtArgs>>): Prisma__MatchResultClient<$Result.GetResult<Prisma.$MatchResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultCountArgs} args - Arguments to filter MatchResults to count.
     * @example
     * // Count the number of MatchResults
     * const count = await prisma.matchResult.count({
     *   where: {
     *     // ... the filter for the MatchResults we want to count
     *   }
     * })
    **/
    count<T extends MatchResultCountArgs>(
      args?: Subset<T, MatchResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchResultAggregateArgs>(args: Subset<T, MatchResultAggregateArgs>): Prisma.PrismaPromise<GetMatchResultAggregateType<T>>

    /**
     * Group by MatchResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchResultGroupByArgs['orderBy'] }
        : { orderBy?: MatchResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchResult model
   */
  readonly fields: MatchResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roundAssignment<T extends RoundAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundAssignmentDefaultArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchResult model
   */
  interface MatchResultFieldRefs {
    readonly id: FieldRef<"MatchResult", 'Int'>
    readonly roundAssignmentId: FieldRef<"MatchResult", 'Int'>
    readonly teamId: FieldRef<"MatchResult", 'Int'>
    readonly rank: FieldRef<"MatchResult", 'Int'>
    readonly points: FieldRef<"MatchResult", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MatchResult findUnique
   */
  export type MatchResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * Filter, which MatchResult to fetch.
     */
    where: MatchResultWhereUniqueInput
  }

  /**
   * MatchResult findUniqueOrThrow
   */
  export type MatchResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * Filter, which MatchResult to fetch.
     */
    where: MatchResultWhereUniqueInput
  }

  /**
   * MatchResult findFirst
   */
  export type MatchResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * Filter, which MatchResult to fetch.
     */
    where?: MatchResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchResults to fetch.
     */
    orderBy?: MatchResultOrderByWithRelationInput | MatchResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchResults.
     */
    cursor?: MatchResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchResults.
     */
    distinct?: MatchResultScalarFieldEnum | MatchResultScalarFieldEnum[]
  }

  /**
   * MatchResult findFirstOrThrow
   */
  export type MatchResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * Filter, which MatchResult to fetch.
     */
    where?: MatchResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchResults to fetch.
     */
    orderBy?: MatchResultOrderByWithRelationInput | MatchResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchResults.
     */
    cursor?: MatchResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchResults.
     */
    distinct?: MatchResultScalarFieldEnum | MatchResultScalarFieldEnum[]
  }

  /**
   * MatchResult findMany
   */
  export type MatchResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * Filter, which MatchResults to fetch.
     */
    where?: MatchResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchResults to fetch.
     */
    orderBy?: MatchResultOrderByWithRelationInput | MatchResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchResults.
     */
    cursor?: MatchResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchResults.
     */
    skip?: number
    distinct?: MatchResultScalarFieldEnum | MatchResultScalarFieldEnum[]
  }

  /**
   * MatchResult create
   */
  export type MatchResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchResult.
     */
    data: XOR<MatchResultCreateInput, MatchResultUncheckedCreateInput>
  }

  /**
   * MatchResult createMany
   */
  export type MatchResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchResults.
     */
    data: MatchResultCreateManyInput | MatchResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchResult createManyAndReturn
   */
  export type MatchResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * The data used to create many MatchResults.
     */
    data: MatchResultCreateManyInput | MatchResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchResult update
   */
  export type MatchResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchResult.
     */
    data: XOR<MatchResultUpdateInput, MatchResultUncheckedUpdateInput>
    /**
     * Choose, which MatchResult to update.
     */
    where: MatchResultWhereUniqueInput
  }

  /**
   * MatchResult updateMany
   */
  export type MatchResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchResults.
     */
    data: XOR<MatchResultUpdateManyMutationInput, MatchResultUncheckedUpdateManyInput>
    /**
     * Filter which MatchResults to update
     */
    where?: MatchResultWhereInput
    /**
     * Limit how many MatchResults to update.
     */
    limit?: number
  }

  /**
   * MatchResult updateManyAndReturn
   */
  export type MatchResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * The data used to update MatchResults.
     */
    data: XOR<MatchResultUpdateManyMutationInput, MatchResultUncheckedUpdateManyInput>
    /**
     * Filter which MatchResults to update
     */
    where?: MatchResultWhereInput
    /**
     * Limit how many MatchResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchResult upsert
   */
  export type MatchResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchResult to update in case it exists.
     */
    where: MatchResultWhereUniqueInput
    /**
     * In case the MatchResult found by the `where` argument doesn't exist, create a new MatchResult with this data.
     */
    create: XOR<MatchResultCreateInput, MatchResultUncheckedCreateInput>
    /**
     * In case the MatchResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchResultUpdateInput, MatchResultUncheckedUpdateInput>
  }

  /**
   * MatchResult delete
   */
  export type MatchResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
    /**
     * Filter which MatchResult to delete.
     */
    where: MatchResultWhereUniqueInput
  }

  /**
   * MatchResult deleteMany
   */
  export type MatchResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchResults to delete
     */
    where?: MatchResultWhereInput
    /**
     * Limit how many MatchResults to delete.
     */
    limit?: number
  }

  /**
   * MatchResult without action
   */
  export type MatchResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchResult
     */
    select?: MatchResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchResult
     */
    omit?: MatchResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchResultInclude<ExtArgs> | null
  }


  /**
   * Model TeamAssignment
   */

  export type AggregateTeamAssignment = {
    _count: TeamAssignmentCountAggregateOutputType | null
    _avg: TeamAssignmentAvgAggregateOutputType | null
    _sum: TeamAssignmentSumAggregateOutputType | null
    _min: TeamAssignmentMinAggregateOutputType | null
    _max: TeamAssignmentMaxAggregateOutputType | null
  }

  export type TeamAssignmentAvgAggregateOutputType = {
    id: number | null
    teamId: number | null
    roundAssignmentId: number | null
  }

  export type TeamAssignmentSumAggregateOutputType = {
    id: number | null
    teamId: number | null
    roundAssignmentId: number | null
  }

  export type TeamAssignmentMinAggregateOutputType = {
    id: number | null
    teamId: number | null
    roundAssignmentId: number | null
    position: $Enums.DebatePosition | null
  }

  export type TeamAssignmentMaxAggregateOutputType = {
    id: number | null
    teamId: number | null
    roundAssignmentId: number | null
    position: $Enums.DebatePosition | null
  }

  export type TeamAssignmentCountAggregateOutputType = {
    id: number
    teamId: number
    roundAssignmentId: number
    position: number
    _all: number
  }


  export type TeamAssignmentAvgAggregateInputType = {
    id?: true
    teamId?: true
    roundAssignmentId?: true
  }

  export type TeamAssignmentSumAggregateInputType = {
    id?: true
    teamId?: true
    roundAssignmentId?: true
  }

  export type TeamAssignmentMinAggregateInputType = {
    id?: true
    teamId?: true
    roundAssignmentId?: true
    position?: true
  }

  export type TeamAssignmentMaxAggregateInputType = {
    id?: true
    teamId?: true
    roundAssignmentId?: true
    position?: true
  }

  export type TeamAssignmentCountAggregateInputType = {
    id?: true
    teamId?: true
    roundAssignmentId?: true
    position?: true
    _all?: true
  }

  export type TeamAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamAssignment to aggregate.
     */
    where?: TeamAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAssignments to fetch.
     */
    orderBy?: TeamAssignmentOrderByWithRelationInput | TeamAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamAssignments
    **/
    _count?: true | TeamAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamAssignmentMaxAggregateInputType
  }

  export type GetTeamAssignmentAggregateType<T extends TeamAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamAssignment[P]>
      : GetScalarType<T[P], AggregateTeamAssignment[P]>
  }




  export type TeamAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAssignmentWhereInput
    orderBy?: TeamAssignmentOrderByWithAggregationInput | TeamAssignmentOrderByWithAggregationInput[]
    by: TeamAssignmentScalarFieldEnum[] | TeamAssignmentScalarFieldEnum
    having?: TeamAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamAssignmentCountAggregateInputType | true
    _avg?: TeamAssignmentAvgAggregateInputType
    _sum?: TeamAssignmentSumAggregateInputType
    _min?: TeamAssignmentMinAggregateInputType
    _max?: TeamAssignmentMaxAggregateInputType
  }

  export type TeamAssignmentGroupByOutputType = {
    id: number
    teamId: number
    roundAssignmentId: number
    position: $Enums.DebatePosition
    _count: TeamAssignmentCountAggregateOutputType | null
    _avg: TeamAssignmentAvgAggregateOutputType | null
    _sum: TeamAssignmentSumAggregateOutputType | null
    _min: TeamAssignmentMinAggregateOutputType | null
    _max: TeamAssignmentMaxAggregateOutputType | null
  }

  type GetTeamAssignmentGroupByPayload<T extends TeamAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], TeamAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type TeamAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    roundAssignmentId?: boolean
    position?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamAssignment"]>

  export type TeamAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    roundAssignmentId?: boolean
    position?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamAssignment"]>

  export type TeamAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    roundAssignmentId?: boolean
    position?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamAssignment"]>

  export type TeamAssignmentSelectScalar = {
    id?: boolean
    teamId?: boolean
    roundAssignmentId?: boolean
    position?: boolean
  }

  export type TeamAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "roundAssignmentId" | "position", ExtArgs["result"]["teamAssignment"]>
  export type TeamAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
  }
  export type TeamAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
  }
  export type TeamAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    roundAssignment?: boolean | RoundAssignmentDefaultArgs<ExtArgs>
  }

  export type $TeamAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamAssignment"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      roundAssignment: Prisma.$RoundAssignmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teamId: number
      roundAssignmentId: number
      position: $Enums.DebatePosition
    }, ExtArgs["result"]["teamAssignment"]>
    composites: {}
  }

  type TeamAssignmentGetPayload<S extends boolean | null | undefined | TeamAssignmentDefaultArgs> = $Result.GetResult<Prisma.$TeamAssignmentPayload, S>

  type TeamAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamAssignmentCountAggregateInputType | true
    }

  export interface TeamAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamAssignment'], meta: { name: 'TeamAssignment' } }
    /**
     * Find zero or one TeamAssignment that matches the filter.
     * @param {TeamAssignmentFindUniqueArgs} args - Arguments to find a TeamAssignment
     * @example
     * // Get one TeamAssignment
     * const teamAssignment = await prisma.teamAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamAssignmentFindUniqueArgs>(args: SelectSubset<T, TeamAssignmentFindUniqueArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamAssignmentFindUniqueOrThrowArgs} args - Arguments to find a TeamAssignment
     * @example
     * // Get one TeamAssignment
     * const teamAssignment = await prisma.teamAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentFindFirstArgs} args - Arguments to find a TeamAssignment
     * @example
     * // Get one TeamAssignment
     * const teamAssignment = await prisma.teamAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamAssignmentFindFirstArgs>(args?: SelectSubset<T, TeamAssignmentFindFirstArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentFindFirstOrThrowArgs} args - Arguments to find a TeamAssignment
     * @example
     * // Get one TeamAssignment
     * const teamAssignment = await prisma.teamAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamAssignments
     * const teamAssignments = await prisma.teamAssignment.findMany()
     * 
     * // Get first 10 TeamAssignments
     * const teamAssignments = await prisma.teamAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamAssignmentWithIdOnly = await prisma.teamAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamAssignmentFindManyArgs>(args?: SelectSubset<T, TeamAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamAssignment.
     * @param {TeamAssignmentCreateArgs} args - Arguments to create a TeamAssignment.
     * @example
     * // Create one TeamAssignment
     * const TeamAssignment = await prisma.teamAssignment.create({
     *   data: {
     *     // ... data to create a TeamAssignment
     *   }
     * })
     * 
     */
    create<T extends TeamAssignmentCreateArgs>(args: SelectSubset<T, TeamAssignmentCreateArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamAssignments.
     * @param {TeamAssignmentCreateManyArgs} args - Arguments to create many TeamAssignments.
     * @example
     * // Create many TeamAssignments
     * const teamAssignment = await prisma.teamAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamAssignmentCreateManyArgs>(args?: SelectSubset<T, TeamAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamAssignments and returns the data saved in the database.
     * @param {TeamAssignmentCreateManyAndReturnArgs} args - Arguments to create many TeamAssignments.
     * @example
     * // Create many TeamAssignments
     * const teamAssignment = await prisma.teamAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamAssignments and only return the `id`
     * const teamAssignmentWithIdOnly = await prisma.teamAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamAssignment.
     * @param {TeamAssignmentDeleteArgs} args - Arguments to delete one TeamAssignment.
     * @example
     * // Delete one TeamAssignment
     * const TeamAssignment = await prisma.teamAssignment.delete({
     *   where: {
     *     // ... filter to delete one TeamAssignment
     *   }
     * })
     * 
     */
    delete<T extends TeamAssignmentDeleteArgs>(args: SelectSubset<T, TeamAssignmentDeleteArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamAssignment.
     * @param {TeamAssignmentUpdateArgs} args - Arguments to update one TeamAssignment.
     * @example
     * // Update one TeamAssignment
     * const teamAssignment = await prisma.teamAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamAssignmentUpdateArgs>(args: SelectSubset<T, TeamAssignmentUpdateArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamAssignments.
     * @param {TeamAssignmentDeleteManyArgs} args - Arguments to filter TeamAssignments to delete.
     * @example
     * // Delete a few TeamAssignments
     * const { count } = await prisma.teamAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamAssignmentDeleteManyArgs>(args?: SelectSubset<T, TeamAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamAssignments
     * const teamAssignment = await prisma.teamAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamAssignmentUpdateManyArgs>(args: SelectSubset<T, TeamAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamAssignments and returns the data updated in the database.
     * @param {TeamAssignmentUpdateManyAndReturnArgs} args - Arguments to update many TeamAssignments.
     * @example
     * // Update many TeamAssignments
     * const teamAssignment = await prisma.teamAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamAssignments and only return the `id`
     * const teamAssignmentWithIdOnly = await prisma.teamAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamAssignment.
     * @param {TeamAssignmentUpsertArgs} args - Arguments to update or create a TeamAssignment.
     * @example
     * // Update or create a TeamAssignment
     * const teamAssignment = await prisma.teamAssignment.upsert({
     *   create: {
     *     // ... data to create a TeamAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamAssignment we want to update
     *   }
     * })
     */
    upsert<T extends TeamAssignmentUpsertArgs>(args: SelectSubset<T, TeamAssignmentUpsertArgs<ExtArgs>>): Prisma__TeamAssignmentClient<$Result.GetResult<Prisma.$TeamAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentCountArgs} args - Arguments to filter TeamAssignments to count.
     * @example
     * // Count the number of TeamAssignments
     * const count = await prisma.teamAssignment.count({
     *   where: {
     *     // ... the filter for the TeamAssignments we want to count
     *   }
     * })
    **/
    count<T extends TeamAssignmentCountArgs>(
      args?: Subset<T, TeamAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAssignmentAggregateArgs>(args: Subset<T, TeamAssignmentAggregateArgs>): Prisma.PrismaPromise<GetTeamAssignmentAggregateType<T>>

    /**
     * Group by TeamAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: TeamAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamAssignment model
   */
  readonly fields: TeamAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roundAssignment<T extends RoundAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoundAssignmentDefaultArgs<ExtArgs>>): Prisma__RoundAssignmentClient<$Result.GetResult<Prisma.$RoundAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamAssignment model
   */
  interface TeamAssignmentFieldRefs {
    readonly id: FieldRef<"TeamAssignment", 'Int'>
    readonly teamId: FieldRef<"TeamAssignment", 'Int'>
    readonly roundAssignmentId: FieldRef<"TeamAssignment", 'Int'>
    readonly position: FieldRef<"TeamAssignment", 'DebatePosition'>
  }
    

  // Custom InputTypes
  /**
   * TeamAssignment findUnique
   */
  export type TeamAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeamAssignment to fetch.
     */
    where: TeamAssignmentWhereUniqueInput
  }

  /**
   * TeamAssignment findUniqueOrThrow
   */
  export type TeamAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeamAssignment to fetch.
     */
    where: TeamAssignmentWhereUniqueInput
  }

  /**
   * TeamAssignment findFirst
   */
  export type TeamAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeamAssignment to fetch.
     */
    where?: TeamAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAssignments to fetch.
     */
    orderBy?: TeamAssignmentOrderByWithRelationInput | TeamAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamAssignments.
     */
    cursor?: TeamAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamAssignments.
     */
    distinct?: TeamAssignmentScalarFieldEnum | TeamAssignmentScalarFieldEnum[]
  }

  /**
   * TeamAssignment findFirstOrThrow
   */
  export type TeamAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeamAssignment to fetch.
     */
    where?: TeamAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAssignments to fetch.
     */
    orderBy?: TeamAssignmentOrderByWithRelationInput | TeamAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamAssignments.
     */
    cursor?: TeamAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamAssignments.
     */
    distinct?: TeamAssignmentScalarFieldEnum | TeamAssignmentScalarFieldEnum[]
  }

  /**
   * TeamAssignment findMany
   */
  export type TeamAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which TeamAssignments to fetch.
     */
    where?: TeamAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAssignments to fetch.
     */
    orderBy?: TeamAssignmentOrderByWithRelationInput | TeamAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamAssignments.
     */
    cursor?: TeamAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAssignments.
     */
    skip?: number
    distinct?: TeamAssignmentScalarFieldEnum | TeamAssignmentScalarFieldEnum[]
  }

  /**
   * TeamAssignment create
   */
  export type TeamAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamAssignment.
     */
    data: XOR<TeamAssignmentCreateInput, TeamAssignmentUncheckedCreateInput>
  }

  /**
   * TeamAssignment createMany
   */
  export type TeamAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamAssignments.
     */
    data: TeamAssignmentCreateManyInput | TeamAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamAssignment createManyAndReturn
   */
  export type TeamAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many TeamAssignments.
     */
    data: TeamAssignmentCreateManyInput | TeamAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamAssignment update
   */
  export type TeamAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamAssignment.
     */
    data: XOR<TeamAssignmentUpdateInput, TeamAssignmentUncheckedUpdateInput>
    /**
     * Choose, which TeamAssignment to update.
     */
    where: TeamAssignmentWhereUniqueInput
  }

  /**
   * TeamAssignment updateMany
   */
  export type TeamAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamAssignments.
     */
    data: XOR<TeamAssignmentUpdateManyMutationInput, TeamAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TeamAssignments to update
     */
    where?: TeamAssignmentWhereInput
    /**
     * Limit how many TeamAssignments to update.
     */
    limit?: number
  }

  /**
   * TeamAssignment updateManyAndReturn
   */
  export type TeamAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update TeamAssignments.
     */
    data: XOR<TeamAssignmentUpdateManyMutationInput, TeamAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which TeamAssignments to update
     */
    where?: TeamAssignmentWhereInput
    /**
     * Limit how many TeamAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamAssignment upsert
   */
  export type TeamAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamAssignment to update in case it exists.
     */
    where: TeamAssignmentWhereUniqueInput
    /**
     * In case the TeamAssignment found by the `where` argument doesn't exist, create a new TeamAssignment with this data.
     */
    create: XOR<TeamAssignmentCreateInput, TeamAssignmentUncheckedCreateInput>
    /**
     * In case the TeamAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamAssignmentUpdateInput, TeamAssignmentUncheckedUpdateInput>
  }

  /**
   * TeamAssignment delete
   */
  export type TeamAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
    /**
     * Filter which TeamAssignment to delete.
     */
    where: TeamAssignmentWhereUniqueInput
  }

  /**
   * TeamAssignment deleteMany
   */
  export type TeamAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamAssignments to delete
     */
    where?: TeamAssignmentWhereInput
    /**
     * Limit how many TeamAssignments to delete.
     */
    limit?: number
  }

  /**
   * TeamAssignment without action
   */
  export type TeamAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAssignment
     */
    select?: TeamAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamAssignment
     */
    omit?: TeamAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamAssignmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const ParticipantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    teamId: 'teamId'
  };

  export type ParticipantScalarFieldEnum = (typeof ParticipantScalarFieldEnum)[keyof typeof ParticipantScalarFieldEnum]


  export const JudgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type JudgeScalarFieldEnum = (typeof JudgeScalarFieldEnum)[keyof typeof JudgeScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoundScalarFieldEnum: {
    id: 'id',
    name: 'name',
    number: 'number'
  };

  export type RoundScalarFieldEnum = (typeof RoundScalarFieldEnum)[keyof typeof RoundScalarFieldEnum]


  export const RoundAssignmentScalarFieldEnum: {
    id: 'id',
    roundId: 'roundId',
    roomId: 'roomId',
    judgeId: 'judgeId'
  };

  export type RoundAssignmentScalarFieldEnum = (typeof RoundAssignmentScalarFieldEnum)[keyof typeof RoundAssignmentScalarFieldEnum]


  export const ScoreScalarFieldEnum: {
    id: 'id',
    judgeId: 'judgeId',
    roundId: 'roundId',
    teamId: 'teamId',
    participantId: 'participantId',
    scoreType: 'scoreType',
    value: 'value'
  };

  export type ScoreScalarFieldEnum = (typeof ScoreScalarFieldEnum)[keyof typeof ScoreScalarFieldEnum]


  export const MatchResultScalarFieldEnum: {
    id: 'id',
    roundAssignmentId: 'roundAssignmentId',
    teamId: 'teamId',
    rank: 'rank',
    points: 'points'
  };

  export type MatchResultScalarFieldEnum = (typeof MatchResultScalarFieldEnum)[keyof typeof MatchResultScalarFieldEnum]


  export const TeamAssignmentScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    roundAssignmentId: 'roundAssignmentId',
    position: 'position'
  };

  export type TeamAssignmentScalarFieldEnum = (typeof TeamAssignmentScalarFieldEnum)[keyof typeof TeamAssignmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ScoreType'
   */
  export type EnumScoreTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreType'>
    


  /**
   * Reference to a field of type 'ScoreType[]'
   */
  export type ListEnumScoreTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScoreType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DebatePosition'
   */
  export type EnumDebatePositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebatePosition'>
    


  /**
   * Reference to a field of type 'DebatePosition[]'
   */
  export type ListEnumDebatePositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DebatePosition[]'>
    
  /**
   * Deep Input Types
   */


  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    participants?: ParticipantListRelationFilter
    scores?: ScoreListRelationFilter
    matchResults?: MatchResultListRelationFilter
    teamAssignments?: TeamAssignmentListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    participants?: ParticipantOrderByRelationAggregateInput
    scores?: ScoreOrderByRelationAggregateInput
    matchResults?: MatchResultOrderByRelationAggregateInput
    teamAssignments?: TeamAssignmentOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    participants?: ParticipantListRelationFilter
    scores?: ScoreListRelationFilter
    matchResults?: MatchResultListRelationFilter
    teamAssignments?: TeamAssignmentListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
  }

  export type ParticipantWhereInput = {
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    id?: IntFilter<"Participant"> | number
    name?: StringFilter<"Participant"> | string
    email?: StringFilter<"Participant"> | string
    teamId?: IntFilter<"Participant"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    scores?: ScoreListRelationFilter
  }

  export type ParticipantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    teamId?: SortOrder
    team?: TeamOrderByWithRelationInput
    scores?: ScoreOrderByRelationAggregateInput
  }

  export type ParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ParticipantWhereInput | ParticipantWhereInput[]
    OR?: ParticipantWhereInput[]
    NOT?: ParticipantWhereInput | ParticipantWhereInput[]
    name?: StringFilter<"Participant"> | string
    teamId?: IntFilter<"Participant"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    scores?: ScoreListRelationFilter
  }, "id" | "email">

  export type ParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    teamId?: SortOrder
    _count?: ParticipantCountOrderByAggregateInput
    _avg?: ParticipantAvgOrderByAggregateInput
    _max?: ParticipantMaxOrderByAggregateInput
    _min?: ParticipantMinOrderByAggregateInput
    _sum?: ParticipantSumOrderByAggregateInput
  }

  export type ParticipantScalarWhereWithAggregatesInput = {
    AND?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    OR?: ParticipantScalarWhereWithAggregatesInput[]
    NOT?: ParticipantScalarWhereWithAggregatesInput | ParticipantScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Participant"> | number
    name?: StringWithAggregatesFilter<"Participant"> | string
    email?: StringWithAggregatesFilter<"Participant"> | string
    teamId?: IntWithAggregatesFilter<"Participant"> | number
  }

  export type JudgeWhereInput = {
    AND?: JudgeWhereInput | JudgeWhereInput[]
    OR?: JudgeWhereInput[]
    NOT?: JudgeWhereInput | JudgeWhereInput[]
    id?: IntFilter<"Judge"> | number
    name?: StringFilter<"Judge"> | string
    email?: StringFilter<"Judge"> | string
    password?: StringFilter<"Judge"> | string
    assignments?: RoundAssignmentListRelationFilter
    scores?: ScoreListRelationFilter
  }

  export type JudgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    assignments?: RoundAssignmentOrderByRelationAggregateInput
    scores?: ScoreOrderByRelationAggregateInput
  }

  export type JudgeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: JudgeWhereInput | JudgeWhereInput[]
    OR?: JudgeWhereInput[]
    NOT?: JudgeWhereInput | JudgeWhereInput[]
    name?: StringFilter<"Judge"> | string
    password?: StringFilter<"Judge"> | string
    assignments?: RoundAssignmentListRelationFilter
    scores?: ScoreListRelationFilter
  }, "id" | "email">

  export type JudgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: JudgeCountOrderByAggregateInput
    _avg?: JudgeAvgOrderByAggregateInput
    _max?: JudgeMaxOrderByAggregateInput
    _min?: JudgeMinOrderByAggregateInput
    _sum?: JudgeSumOrderByAggregateInput
  }

  export type JudgeScalarWhereWithAggregatesInput = {
    AND?: JudgeScalarWhereWithAggregatesInput | JudgeScalarWhereWithAggregatesInput[]
    OR?: JudgeScalarWhereWithAggregatesInput[]
    NOT?: JudgeScalarWhereWithAggregatesInput | JudgeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Judge"> | number
    name?: StringWithAggregatesFilter<"Judge"> | string
    email?: StringWithAggregatesFilter<"Judge"> | string
    password?: StringWithAggregatesFilter<"Judge"> | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    name?: StringFilter<"Room"> | string
    assignments?: RoundAssignmentListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    assignments?: RoundAssignmentOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    name?: StringFilter<"Room"> | string
    assignments?: RoundAssignmentListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    name?: StringWithAggregatesFilter<"Room"> | string
  }

  export type RoundWhereInput = {
    AND?: RoundWhereInput | RoundWhereInput[]
    OR?: RoundWhereInput[]
    NOT?: RoundWhereInput | RoundWhereInput[]
    id?: IntFilter<"Round"> | number
    name?: StringFilter<"Round"> | string
    number?: IntFilter<"Round"> | number
    assignments?: RoundAssignmentListRelationFilter
    Score?: ScoreListRelationFilter
  }

  export type RoundOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    assignments?: RoundAssignmentOrderByRelationAggregateInput
    Score?: ScoreOrderByRelationAggregateInput
  }

  export type RoundWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoundWhereInput | RoundWhereInput[]
    OR?: RoundWhereInput[]
    NOT?: RoundWhereInput | RoundWhereInput[]
    name?: StringFilter<"Round"> | string
    number?: IntFilter<"Round"> | number
    assignments?: RoundAssignmentListRelationFilter
    Score?: ScoreListRelationFilter
  }, "id">

  export type RoundOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
    _count?: RoundCountOrderByAggregateInput
    _avg?: RoundAvgOrderByAggregateInput
    _max?: RoundMaxOrderByAggregateInput
    _min?: RoundMinOrderByAggregateInput
    _sum?: RoundSumOrderByAggregateInput
  }

  export type RoundScalarWhereWithAggregatesInput = {
    AND?: RoundScalarWhereWithAggregatesInput | RoundScalarWhereWithAggregatesInput[]
    OR?: RoundScalarWhereWithAggregatesInput[]
    NOT?: RoundScalarWhereWithAggregatesInput | RoundScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Round"> | number
    name?: StringWithAggregatesFilter<"Round"> | string
    number?: IntWithAggregatesFilter<"Round"> | number
  }

  export type RoundAssignmentWhereInput = {
    AND?: RoundAssignmentWhereInput | RoundAssignmentWhereInput[]
    OR?: RoundAssignmentWhereInput[]
    NOT?: RoundAssignmentWhereInput | RoundAssignmentWhereInput[]
    id?: IntFilter<"RoundAssignment"> | number
    roundId?: IntFilter<"RoundAssignment"> | number
    roomId?: IntFilter<"RoundAssignment"> | number
    judgeId?: IntNullableFilter<"RoundAssignment"> | number | null
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    judge?: XOR<JudgeNullableScalarRelationFilter, JudgeWhereInput> | null
    matchResults?: MatchResultListRelationFilter
    teamAssignments?: TeamAssignmentListRelationFilter
  }

  export type RoundAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrderInput | SortOrder
    round?: RoundOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    judge?: JudgeOrderByWithRelationInput
    matchResults?: MatchResultOrderByRelationAggregateInput
    teamAssignments?: TeamAssignmentOrderByRelationAggregateInput
  }

  export type RoundAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoundAssignmentWhereInput | RoundAssignmentWhereInput[]
    OR?: RoundAssignmentWhereInput[]
    NOT?: RoundAssignmentWhereInput | RoundAssignmentWhereInput[]
    roundId?: IntFilter<"RoundAssignment"> | number
    roomId?: IntFilter<"RoundAssignment"> | number
    judgeId?: IntNullableFilter<"RoundAssignment"> | number | null
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    judge?: XOR<JudgeNullableScalarRelationFilter, JudgeWhereInput> | null
    matchResults?: MatchResultListRelationFilter
    teamAssignments?: TeamAssignmentListRelationFilter
  }, "id">

  export type RoundAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrderInput | SortOrder
    _count?: RoundAssignmentCountOrderByAggregateInput
    _avg?: RoundAssignmentAvgOrderByAggregateInput
    _max?: RoundAssignmentMaxOrderByAggregateInput
    _min?: RoundAssignmentMinOrderByAggregateInput
    _sum?: RoundAssignmentSumOrderByAggregateInput
  }

  export type RoundAssignmentScalarWhereWithAggregatesInput = {
    AND?: RoundAssignmentScalarWhereWithAggregatesInput | RoundAssignmentScalarWhereWithAggregatesInput[]
    OR?: RoundAssignmentScalarWhereWithAggregatesInput[]
    NOT?: RoundAssignmentScalarWhereWithAggregatesInput | RoundAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoundAssignment"> | number
    roundId?: IntWithAggregatesFilter<"RoundAssignment"> | number
    roomId?: IntWithAggregatesFilter<"RoundAssignment"> | number
    judgeId?: IntNullableWithAggregatesFilter<"RoundAssignment"> | number | null
  }

  export type ScoreWhereInput = {
    AND?: ScoreWhereInput | ScoreWhereInput[]
    OR?: ScoreWhereInput[]
    NOT?: ScoreWhereInput | ScoreWhereInput[]
    id?: IntFilter<"Score"> | number
    judgeId?: IntFilter<"Score"> | number
    roundId?: IntFilter<"Score"> | number
    teamId?: IntFilter<"Score"> | number
    participantId?: IntNullableFilter<"Score"> | number | null
    scoreType?: EnumScoreTypeFilter<"Score"> | $Enums.ScoreType
    value?: FloatFilter<"Score"> | number
    judge?: XOR<JudgeScalarRelationFilter, JudgeWhereInput>
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
  }

  export type ScoreOrderByWithRelationInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    scoreType?: SortOrder
    value?: SortOrder
    judge?: JudgeOrderByWithRelationInput
    round?: RoundOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    participant?: ParticipantOrderByWithRelationInput
  }

  export type ScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScoreWhereInput | ScoreWhereInput[]
    OR?: ScoreWhereInput[]
    NOT?: ScoreWhereInput | ScoreWhereInput[]
    judgeId?: IntFilter<"Score"> | number
    roundId?: IntFilter<"Score"> | number
    teamId?: IntFilter<"Score"> | number
    participantId?: IntNullableFilter<"Score"> | number | null
    scoreType?: EnumScoreTypeFilter<"Score"> | $Enums.ScoreType
    value?: FloatFilter<"Score"> | number
    judge?: XOR<JudgeScalarRelationFilter, JudgeWhereInput>
    round?: XOR<RoundScalarRelationFilter, RoundWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    participant?: XOR<ParticipantNullableScalarRelationFilter, ParticipantWhereInput> | null
  }, "id">

  export type ScoreOrderByWithAggregationInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrderInput | SortOrder
    scoreType?: SortOrder
    value?: SortOrder
    _count?: ScoreCountOrderByAggregateInput
    _avg?: ScoreAvgOrderByAggregateInput
    _max?: ScoreMaxOrderByAggregateInput
    _min?: ScoreMinOrderByAggregateInput
    _sum?: ScoreSumOrderByAggregateInput
  }

  export type ScoreScalarWhereWithAggregatesInput = {
    AND?: ScoreScalarWhereWithAggregatesInput | ScoreScalarWhereWithAggregatesInput[]
    OR?: ScoreScalarWhereWithAggregatesInput[]
    NOT?: ScoreScalarWhereWithAggregatesInput | ScoreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Score"> | number
    judgeId?: IntWithAggregatesFilter<"Score"> | number
    roundId?: IntWithAggregatesFilter<"Score"> | number
    teamId?: IntWithAggregatesFilter<"Score"> | number
    participantId?: IntNullableWithAggregatesFilter<"Score"> | number | null
    scoreType?: EnumScoreTypeWithAggregatesFilter<"Score"> | $Enums.ScoreType
    value?: FloatWithAggregatesFilter<"Score"> | number
  }

  export type MatchResultWhereInput = {
    AND?: MatchResultWhereInput | MatchResultWhereInput[]
    OR?: MatchResultWhereInput[]
    NOT?: MatchResultWhereInput | MatchResultWhereInput[]
    id?: IntFilter<"MatchResult"> | number
    roundAssignmentId?: IntFilter<"MatchResult"> | number
    teamId?: IntFilter<"MatchResult"> | number
    rank?: IntFilter<"MatchResult"> | number
    points?: IntFilter<"MatchResult"> | number
    roundAssignment?: XOR<RoundAssignmentScalarRelationFilter, RoundAssignmentWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type MatchResultOrderByWithRelationInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
    roundAssignment?: RoundAssignmentOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type MatchResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MatchResultWhereInput | MatchResultWhereInput[]
    OR?: MatchResultWhereInput[]
    NOT?: MatchResultWhereInput | MatchResultWhereInput[]
    roundAssignmentId?: IntFilter<"MatchResult"> | number
    teamId?: IntFilter<"MatchResult"> | number
    rank?: IntFilter<"MatchResult"> | number
    points?: IntFilter<"MatchResult"> | number
    roundAssignment?: XOR<RoundAssignmentScalarRelationFilter, RoundAssignmentWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id">

  export type MatchResultOrderByWithAggregationInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
    _count?: MatchResultCountOrderByAggregateInput
    _avg?: MatchResultAvgOrderByAggregateInput
    _max?: MatchResultMaxOrderByAggregateInput
    _min?: MatchResultMinOrderByAggregateInput
    _sum?: MatchResultSumOrderByAggregateInput
  }

  export type MatchResultScalarWhereWithAggregatesInput = {
    AND?: MatchResultScalarWhereWithAggregatesInput | MatchResultScalarWhereWithAggregatesInput[]
    OR?: MatchResultScalarWhereWithAggregatesInput[]
    NOT?: MatchResultScalarWhereWithAggregatesInput | MatchResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchResult"> | number
    roundAssignmentId?: IntWithAggregatesFilter<"MatchResult"> | number
    teamId?: IntWithAggregatesFilter<"MatchResult"> | number
    rank?: IntWithAggregatesFilter<"MatchResult"> | number
    points?: IntWithAggregatesFilter<"MatchResult"> | number
  }

  export type TeamAssignmentWhereInput = {
    AND?: TeamAssignmentWhereInput | TeamAssignmentWhereInput[]
    OR?: TeamAssignmentWhereInput[]
    NOT?: TeamAssignmentWhereInput | TeamAssignmentWhereInput[]
    id?: IntFilter<"TeamAssignment"> | number
    teamId?: IntFilter<"TeamAssignment"> | number
    roundAssignmentId?: IntFilter<"TeamAssignment"> | number
    position?: EnumDebatePositionFilter<"TeamAssignment"> | $Enums.DebatePosition
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    roundAssignment?: XOR<RoundAssignmentScalarRelationFilter, RoundAssignmentWhereInput>
  }

  export type TeamAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
    position?: SortOrder
    team?: TeamOrderByWithRelationInput
    roundAssignment?: RoundAssignmentOrderByWithRelationInput
  }

  export type TeamAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamAssignmentWhereInput | TeamAssignmentWhereInput[]
    OR?: TeamAssignmentWhereInput[]
    NOT?: TeamAssignmentWhereInput | TeamAssignmentWhereInput[]
    teamId?: IntFilter<"TeamAssignment"> | number
    roundAssignmentId?: IntFilter<"TeamAssignment"> | number
    position?: EnumDebatePositionFilter<"TeamAssignment"> | $Enums.DebatePosition
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    roundAssignment?: XOR<RoundAssignmentScalarRelationFilter, RoundAssignmentWhereInput>
  }, "id">

  export type TeamAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
    position?: SortOrder
    _count?: TeamAssignmentCountOrderByAggregateInput
    _avg?: TeamAssignmentAvgOrderByAggregateInput
    _max?: TeamAssignmentMaxOrderByAggregateInput
    _min?: TeamAssignmentMinOrderByAggregateInput
    _sum?: TeamAssignmentSumOrderByAggregateInput
  }

  export type TeamAssignmentScalarWhereWithAggregatesInput = {
    AND?: TeamAssignmentScalarWhereWithAggregatesInput | TeamAssignmentScalarWhereWithAggregatesInput[]
    OR?: TeamAssignmentScalarWhereWithAggregatesInput[]
    NOT?: TeamAssignmentScalarWhereWithAggregatesInput | TeamAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TeamAssignment"> | number
    teamId?: IntWithAggregatesFilter<"TeamAssignment"> | number
    roundAssignmentId?: IntWithAggregatesFilter<"TeamAssignment"> | number
    position?: EnumDebatePositionWithAggregatesFilter<"TeamAssignment"> | $Enums.DebatePosition
  }

  export type TeamCreateInput = {
    name: string
    participants?: ParticipantCreateNestedManyWithoutTeamInput
    scores?: ScoreCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    participants?: ParticipantUncheckedCreateNestedManyWithoutTeamInput
    scores?: ScoreUncheckedCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUpdateManyWithoutTeamNestedInput
    scores?: ScoreUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUncheckedUpdateManyWithoutTeamNestedInput
    scores?: ScoreUncheckedUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUncheckedUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ParticipantCreateInput = {
    name: string
    email: string
    team: TeamCreateNestedOneWithoutParticipantsInput
    scores?: ScoreCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    teamId: number
    scores?: ScoreUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutParticipantsNestedInput
    scores?: ScoreUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    scores?: ScoreUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantCreateManyInput = {
    id?: number
    name: string
    email: string
    teamId: number
  }

  export type ParticipantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type ParticipantUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type JudgeCreateInput = {
    name: string
    email: string
    password: string
    assignments?: RoundAssignmentCreateNestedManyWithoutJudgeInput
    scores?: ScoreCreateNestedManyWithoutJudgeInput
  }

  export type JudgeUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    assignments?: RoundAssignmentUncheckedCreateNestedManyWithoutJudgeInput
    scores?: ScoreUncheckedCreateNestedManyWithoutJudgeInput
  }

  export type JudgeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    assignments?: RoundAssignmentUpdateManyWithoutJudgeNestedInput
    scores?: ScoreUpdateManyWithoutJudgeNestedInput
  }

  export type JudgeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    assignments?: RoundAssignmentUncheckedUpdateManyWithoutJudgeNestedInput
    scores?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput
  }

  export type JudgeCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
  }

  export type JudgeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type JudgeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RoomCreateInput = {
    name: string
    assignments?: RoundAssignmentCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    name: string
    assignments?: RoundAssignmentUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    assignments?: RoundAssignmentUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    assignments?: RoundAssignmentUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: number
    name: string
  }

  export type RoomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoundCreateInput = {
    name: string
    number: number
    assignments?: RoundAssignmentCreateNestedManyWithoutRoundInput
    Score?: ScoreCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateInput = {
    id?: number
    name: string
    number: number
    assignments?: RoundAssignmentUncheckedCreateNestedManyWithoutRoundInput
    Score?: ScoreUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    assignments?: RoundAssignmentUpdateManyWithoutRoundNestedInput
    Score?: ScoreUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    assignments?: RoundAssignmentUncheckedUpdateManyWithoutRoundNestedInput
    Score?: ScoreUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type RoundCreateManyInput = {
    id?: number
    name: string
    number: number
  }

  export type RoundUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type RoundUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type RoundAssignmentCreateInput = {
    round: RoundCreateNestedOneWithoutAssignmentsInput
    room: RoomCreateNestedOneWithoutAssignmentsInput
    judge?: JudgeCreateNestedOneWithoutAssignmentsInput
    matchResults?: MatchResultCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUncheckedCreateInput = {
    id?: number
    roundId: number
    roomId: number
    judgeId?: number | null
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUpdateInput = {
    round?: RoundUpdateOneRequiredWithoutAssignmentsNestedInput
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
    judge?: JudgeUpdateOneWithoutAssignmentsNestedInput
    matchResults?: MatchResultUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
    matchResults?: MatchResultUncheckedUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentCreateManyInput = {
    id?: number
    roundId: number
    roomId: number
    judgeId?: number | null
  }

  export type RoundAssignmentUpdateManyMutationInput = {

  }

  export type RoundAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScoreCreateInput = {
    scoreType: $Enums.ScoreType
    value: number
    judge: JudgeCreateNestedOneWithoutScoresInput
    round: RoundCreateNestedOneWithoutScoreInput
    team: TeamCreateNestedOneWithoutScoresInput
    participant?: ParticipantCreateNestedOneWithoutScoresInput
  }

  export type ScoreUncheckedCreateInput = {
    id?: number
    judgeId: number
    roundId: number
    teamId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreUpdateInput = {
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput
    round?: RoundUpdateOneRequiredWithoutScoreNestedInput
    team?: TeamUpdateOneRequiredWithoutScoresNestedInput
    participant?: ParticipantUpdateOneWithoutScoresNestedInput
  }

  export type ScoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type ScoreCreateManyInput = {
    id?: number
    judgeId: number
    roundId: number
    teamId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreUpdateManyMutationInput = {
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type ScoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type MatchResultCreateInput = {
    rank: number
    points: number
    roundAssignment: RoundAssignmentCreateNestedOneWithoutMatchResultsInput
    team: TeamCreateNestedOneWithoutMatchResultsInput
  }

  export type MatchResultUncheckedCreateInput = {
    id?: number
    roundAssignmentId: number
    teamId: number
    rank: number
    points: number
  }

  export type MatchResultUpdateInput = {
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    roundAssignment?: RoundAssignmentUpdateOneRequiredWithoutMatchResultsNestedInput
    team?: TeamUpdateOneRequiredWithoutMatchResultsNestedInput
  }

  export type MatchResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type MatchResultCreateManyInput = {
    id?: number
    roundAssignmentId: number
    teamId: number
    rank: number
    points: number
  }

  export type MatchResultUpdateManyMutationInput = {
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type MatchResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TeamAssignmentCreateInput = {
    position: $Enums.DebatePosition
    team: TeamCreateNestedOneWithoutTeamAssignmentsInput
    roundAssignment: RoundAssignmentCreateNestedOneWithoutTeamAssignmentsInput
  }

  export type TeamAssignmentUncheckedCreateInput = {
    id?: number
    teamId: number
    roundAssignmentId: number
    position: $Enums.DebatePosition
  }

  export type TeamAssignmentUpdateInput = {
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
    team?: TeamUpdateOneRequiredWithoutTeamAssignmentsNestedInput
    roundAssignment?: RoundAssignmentUpdateOneRequiredWithoutTeamAssignmentsNestedInput
  }

  export type TeamAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }

  export type TeamAssignmentCreateManyInput = {
    id?: number
    teamId: number
    roundAssignmentId: number
    position: $Enums.DebatePosition
  }

  export type TeamAssignmentUpdateManyMutationInput = {
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }

  export type TeamAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ParticipantListRelationFilter = {
    every?: ParticipantWhereInput
    some?: ParticipantWhereInput
    none?: ParticipantWhereInput
  }

  export type ScoreListRelationFilter = {
    every?: ScoreWhereInput
    some?: ScoreWhereInput
    none?: ScoreWhereInput
  }

  export type MatchResultListRelationFilter = {
    every?: MatchResultWhereInput
    some?: MatchResultWhereInput
    none?: MatchResultWhereInput
  }

  export type TeamAssignmentListRelationFilter = {
    every?: TeamAssignmentWhereInput
    some?: TeamAssignmentWhereInput
    none?: TeamAssignmentWhereInput
  }

  export type ParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type ParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    teamId?: SortOrder
  }

  export type ParticipantAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type ParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    teamId?: SortOrder
  }

  export type ParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    teamId?: SortOrder
  }

  export type ParticipantSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
  }

  export type RoundAssignmentListRelationFilter = {
    every?: RoundAssignmentWhereInput
    some?: RoundAssignmentWhereInput
    none?: RoundAssignmentWhereInput
  }

  export type RoundAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JudgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type JudgeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JudgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type JudgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type JudgeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoundCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
  }

  export type RoundAvgOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type RoundMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
  }

  export type RoundMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    number?: SortOrder
  }

  export type RoundSumOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RoundScalarRelationFilter = {
    is?: RoundWhereInput
    isNot?: RoundWhereInput
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type JudgeNullableScalarRelationFilter = {
    is?: JudgeWhereInput | null
    isNot?: JudgeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RoundAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrder
  }

  export type RoundAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrder
  }

  export type RoundAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrder
  }

  export type RoundAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrder
  }

  export type RoundAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    roundId?: SortOrder
    roomId?: SortOrder
    judgeId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumScoreTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeFilter<$PrismaModel> | $Enums.ScoreType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type JudgeScalarRelationFilter = {
    is?: JudgeWhereInput
    isNot?: JudgeWhereInput
  }

  export type ParticipantNullableScalarRelationFilter = {
    is?: ParticipantWhereInput | null
    isNot?: ParticipantWhereInput | null
  }

  export type ScoreCountOrderByAggregateInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrder
    scoreType?: SortOrder
    value?: SortOrder
  }

  export type ScoreAvgOrderByAggregateInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrder
    value?: SortOrder
  }

  export type ScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrder
    scoreType?: SortOrder
    value?: SortOrder
  }

  export type ScoreMinOrderByAggregateInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrder
    scoreType?: SortOrder
    value?: SortOrder
  }

  export type ScoreSumOrderByAggregateInput = {
    id?: SortOrder
    judgeId?: SortOrder
    roundId?: SortOrder
    teamId?: SortOrder
    participantId?: SortOrder
    value?: SortOrder
  }

  export type EnumScoreTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoreType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreTypeFilter<$PrismaModel>
    _max?: NestedEnumScoreTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RoundAssignmentScalarRelationFilter = {
    is?: RoundAssignmentWhereInput
    isNot?: RoundAssignmentWhereInput
  }

  export type MatchResultCountOrderByAggregateInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
  }

  export type MatchResultAvgOrderByAggregateInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
  }

  export type MatchResultMaxOrderByAggregateInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
  }

  export type MatchResultMinOrderByAggregateInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
  }

  export type MatchResultSumOrderByAggregateInput = {
    id?: SortOrder
    roundAssignmentId?: SortOrder
    teamId?: SortOrder
    rank?: SortOrder
    points?: SortOrder
  }

  export type EnumDebatePositionFilter<$PrismaModel = never> = {
    equals?: $Enums.DebatePosition | EnumDebatePositionFieldRefInput<$PrismaModel>
    in?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    not?: NestedEnumDebatePositionFilter<$PrismaModel> | $Enums.DebatePosition
  }

  export type TeamAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
    position?: SortOrder
  }

  export type TeamAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
  }

  export type TeamAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
    position?: SortOrder
  }

  export type TeamAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
    position?: SortOrder
  }

  export type TeamAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    roundAssignmentId?: SortOrder
  }

  export type EnumDebatePositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebatePosition | EnumDebatePositionFieldRefInput<$PrismaModel>
    in?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    not?: NestedEnumDebatePositionWithAggregatesFilter<$PrismaModel> | $Enums.DebatePosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebatePositionFilter<$PrismaModel>
    _max?: NestedEnumDebatePositionFilter<$PrismaModel>
  }

  export type ParticipantCreateNestedManyWithoutTeamInput = {
    create?: XOR<ParticipantCreateWithoutTeamInput, ParticipantUncheckedCreateWithoutTeamInput> | ParticipantCreateWithoutTeamInput[] | ParticipantUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutTeamInput | ParticipantCreateOrConnectWithoutTeamInput[]
    createMany?: ParticipantCreateManyTeamInputEnvelope
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
  }

  export type ScoreCreateNestedManyWithoutTeamInput = {
    create?: XOR<ScoreCreateWithoutTeamInput, ScoreUncheckedCreateWithoutTeamInput> | ScoreCreateWithoutTeamInput[] | ScoreUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutTeamInput | ScoreCreateOrConnectWithoutTeamInput[]
    createMany?: ScoreCreateManyTeamInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type MatchResultCreateNestedManyWithoutTeamInput = {
    create?: XOR<MatchResultCreateWithoutTeamInput, MatchResultUncheckedCreateWithoutTeamInput> | MatchResultCreateWithoutTeamInput[] | MatchResultUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutTeamInput | MatchResultCreateOrConnectWithoutTeamInput[]
    createMany?: MatchResultCreateManyTeamInputEnvelope
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
  }

  export type TeamAssignmentCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamAssignmentCreateWithoutTeamInput, TeamAssignmentUncheckedCreateWithoutTeamInput> | TeamAssignmentCreateWithoutTeamInput[] | TeamAssignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutTeamInput | TeamAssignmentCreateOrConnectWithoutTeamInput[]
    createMany?: TeamAssignmentCreateManyTeamInputEnvelope
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
  }

  export type ParticipantUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ParticipantCreateWithoutTeamInput, ParticipantUncheckedCreateWithoutTeamInput> | ParticipantCreateWithoutTeamInput[] | ParticipantUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutTeamInput | ParticipantCreateOrConnectWithoutTeamInput[]
    createMany?: ParticipantCreateManyTeamInputEnvelope
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
  }

  export type ScoreUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ScoreCreateWithoutTeamInput, ScoreUncheckedCreateWithoutTeamInput> | ScoreCreateWithoutTeamInput[] | ScoreUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutTeamInput | ScoreCreateOrConnectWithoutTeamInput[]
    createMany?: ScoreCreateManyTeamInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type MatchResultUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<MatchResultCreateWithoutTeamInput, MatchResultUncheckedCreateWithoutTeamInput> | MatchResultCreateWithoutTeamInput[] | MatchResultUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutTeamInput | MatchResultCreateOrConnectWithoutTeamInput[]
    createMany?: MatchResultCreateManyTeamInputEnvelope
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
  }

  export type TeamAssignmentUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamAssignmentCreateWithoutTeamInput, TeamAssignmentUncheckedCreateWithoutTeamInput> | TeamAssignmentCreateWithoutTeamInput[] | TeamAssignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutTeamInput | TeamAssignmentCreateOrConnectWithoutTeamInput[]
    createMany?: TeamAssignmentCreateManyTeamInputEnvelope
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ParticipantUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ParticipantCreateWithoutTeamInput, ParticipantUncheckedCreateWithoutTeamInput> | ParticipantCreateWithoutTeamInput[] | ParticipantUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutTeamInput | ParticipantCreateOrConnectWithoutTeamInput[]
    upsert?: ParticipantUpsertWithWhereUniqueWithoutTeamInput | ParticipantUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ParticipantCreateManyTeamInputEnvelope
    set?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    disconnect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    delete?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    update?: ParticipantUpdateWithWhereUniqueWithoutTeamInput | ParticipantUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ParticipantUpdateManyWithWhereWithoutTeamInput | ParticipantUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
  }

  export type ScoreUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ScoreCreateWithoutTeamInput, ScoreUncheckedCreateWithoutTeamInput> | ScoreCreateWithoutTeamInput[] | ScoreUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutTeamInput | ScoreCreateOrConnectWithoutTeamInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutTeamInput | ScoreUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ScoreCreateManyTeamInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutTeamInput | ScoreUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutTeamInput | ScoreUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type MatchResultUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MatchResultCreateWithoutTeamInput, MatchResultUncheckedCreateWithoutTeamInput> | MatchResultCreateWithoutTeamInput[] | MatchResultUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutTeamInput | MatchResultCreateOrConnectWithoutTeamInput[]
    upsert?: MatchResultUpsertWithWhereUniqueWithoutTeamInput | MatchResultUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MatchResultCreateManyTeamInputEnvelope
    set?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    disconnect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    delete?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    update?: MatchResultUpdateWithWhereUniqueWithoutTeamInput | MatchResultUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MatchResultUpdateManyWithWhereWithoutTeamInput | MatchResultUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MatchResultScalarWhereInput | MatchResultScalarWhereInput[]
  }

  export type TeamAssignmentUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamAssignmentCreateWithoutTeamInput, TeamAssignmentUncheckedCreateWithoutTeamInput> | TeamAssignmentCreateWithoutTeamInput[] | TeamAssignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutTeamInput | TeamAssignmentCreateOrConnectWithoutTeamInput[]
    upsert?: TeamAssignmentUpsertWithWhereUniqueWithoutTeamInput | TeamAssignmentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamAssignmentCreateManyTeamInputEnvelope
    set?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    disconnect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    delete?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    update?: TeamAssignmentUpdateWithWhereUniqueWithoutTeamInput | TeamAssignmentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamAssignmentUpdateManyWithWhereWithoutTeamInput | TeamAssignmentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamAssignmentScalarWhereInput | TeamAssignmentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ParticipantUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ParticipantCreateWithoutTeamInput, ParticipantUncheckedCreateWithoutTeamInput> | ParticipantCreateWithoutTeamInput[] | ParticipantUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ParticipantCreateOrConnectWithoutTeamInput | ParticipantCreateOrConnectWithoutTeamInput[]
    upsert?: ParticipantUpsertWithWhereUniqueWithoutTeamInput | ParticipantUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ParticipantCreateManyTeamInputEnvelope
    set?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    disconnect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    delete?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    connect?: ParticipantWhereUniqueInput | ParticipantWhereUniqueInput[]
    update?: ParticipantUpdateWithWhereUniqueWithoutTeamInput | ParticipantUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ParticipantUpdateManyWithWhereWithoutTeamInput | ParticipantUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
  }

  export type ScoreUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ScoreCreateWithoutTeamInput, ScoreUncheckedCreateWithoutTeamInput> | ScoreCreateWithoutTeamInput[] | ScoreUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutTeamInput | ScoreCreateOrConnectWithoutTeamInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutTeamInput | ScoreUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ScoreCreateManyTeamInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutTeamInput | ScoreUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutTeamInput | ScoreUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type MatchResultUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<MatchResultCreateWithoutTeamInput, MatchResultUncheckedCreateWithoutTeamInput> | MatchResultCreateWithoutTeamInput[] | MatchResultUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutTeamInput | MatchResultCreateOrConnectWithoutTeamInput[]
    upsert?: MatchResultUpsertWithWhereUniqueWithoutTeamInput | MatchResultUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: MatchResultCreateManyTeamInputEnvelope
    set?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    disconnect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    delete?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    update?: MatchResultUpdateWithWhereUniqueWithoutTeamInput | MatchResultUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: MatchResultUpdateManyWithWhereWithoutTeamInput | MatchResultUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: MatchResultScalarWhereInput | MatchResultScalarWhereInput[]
  }

  export type TeamAssignmentUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamAssignmentCreateWithoutTeamInput, TeamAssignmentUncheckedCreateWithoutTeamInput> | TeamAssignmentCreateWithoutTeamInput[] | TeamAssignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutTeamInput | TeamAssignmentCreateOrConnectWithoutTeamInput[]
    upsert?: TeamAssignmentUpsertWithWhereUniqueWithoutTeamInput | TeamAssignmentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamAssignmentCreateManyTeamInputEnvelope
    set?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    disconnect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    delete?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    update?: TeamAssignmentUpdateWithWhereUniqueWithoutTeamInput | TeamAssignmentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamAssignmentUpdateManyWithWhereWithoutTeamInput | TeamAssignmentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamAssignmentScalarWhereInput | TeamAssignmentScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<TeamCreateWithoutParticipantsInput, TeamUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutParticipantsInput
    connect?: TeamWhereUniqueInput
  }

  export type ScoreCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ScoreCreateWithoutParticipantInput, ScoreUncheckedCreateWithoutParticipantInput> | ScoreCreateWithoutParticipantInput[] | ScoreUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutParticipantInput | ScoreCreateOrConnectWithoutParticipantInput[]
    createMany?: ScoreCreateManyParticipantInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type ScoreUncheckedCreateNestedManyWithoutParticipantInput = {
    create?: XOR<ScoreCreateWithoutParticipantInput, ScoreUncheckedCreateWithoutParticipantInput> | ScoreCreateWithoutParticipantInput[] | ScoreUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutParticipantInput | ScoreCreateOrConnectWithoutParticipantInput[]
    createMany?: ScoreCreateManyParticipantInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type TeamUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<TeamCreateWithoutParticipantsInput, TeamUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutParticipantsInput
    upsert?: TeamUpsertWithoutParticipantsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutParticipantsInput, TeamUpdateWithoutParticipantsInput>, TeamUncheckedUpdateWithoutParticipantsInput>
  }

  export type ScoreUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ScoreCreateWithoutParticipantInput, ScoreUncheckedCreateWithoutParticipantInput> | ScoreCreateWithoutParticipantInput[] | ScoreUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutParticipantInput | ScoreCreateOrConnectWithoutParticipantInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutParticipantInput | ScoreUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ScoreCreateManyParticipantInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutParticipantInput | ScoreUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutParticipantInput | ScoreUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type ScoreUncheckedUpdateManyWithoutParticipantNestedInput = {
    create?: XOR<ScoreCreateWithoutParticipantInput, ScoreUncheckedCreateWithoutParticipantInput> | ScoreCreateWithoutParticipantInput[] | ScoreUncheckedCreateWithoutParticipantInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutParticipantInput | ScoreCreateOrConnectWithoutParticipantInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutParticipantInput | ScoreUpsertWithWhereUniqueWithoutParticipantInput[]
    createMany?: ScoreCreateManyParticipantInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutParticipantInput | ScoreUpdateWithWhereUniqueWithoutParticipantInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutParticipantInput | ScoreUpdateManyWithWhereWithoutParticipantInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type RoundAssignmentCreateNestedManyWithoutJudgeInput = {
    create?: XOR<RoundAssignmentCreateWithoutJudgeInput, RoundAssignmentUncheckedCreateWithoutJudgeInput> | RoundAssignmentCreateWithoutJudgeInput[] | RoundAssignmentUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutJudgeInput | RoundAssignmentCreateOrConnectWithoutJudgeInput[]
    createMany?: RoundAssignmentCreateManyJudgeInputEnvelope
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
  }

  export type ScoreCreateNestedManyWithoutJudgeInput = {
    create?: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput> | ScoreCreateWithoutJudgeInput[] | ScoreUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutJudgeInput | ScoreCreateOrConnectWithoutJudgeInput[]
    createMany?: ScoreCreateManyJudgeInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type RoundAssignmentUncheckedCreateNestedManyWithoutJudgeInput = {
    create?: XOR<RoundAssignmentCreateWithoutJudgeInput, RoundAssignmentUncheckedCreateWithoutJudgeInput> | RoundAssignmentCreateWithoutJudgeInput[] | RoundAssignmentUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutJudgeInput | RoundAssignmentCreateOrConnectWithoutJudgeInput[]
    createMany?: RoundAssignmentCreateManyJudgeInputEnvelope
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
  }

  export type ScoreUncheckedCreateNestedManyWithoutJudgeInput = {
    create?: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput> | ScoreCreateWithoutJudgeInput[] | ScoreUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutJudgeInput | ScoreCreateOrConnectWithoutJudgeInput[]
    createMany?: ScoreCreateManyJudgeInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type RoundAssignmentUpdateManyWithoutJudgeNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutJudgeInput, RoundAssignmentUncheckedCreateWithoutJudgeInput> | RoundAssignmentCreateWithoutJudgeInput[] | RoundAssignmentUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutJudgeInput | RoundAssignmentCreateOrConnectWithoutJudgeInput[]
    upsert?: RoundAssignmentUpsertWithWhereUniqueWithoutJudgeInput | RoundAssignmentUpsertWithWhereUniqueWithoutJudgeInput[]
    createMany?: RoundAssignmentCreateManyJudgeInputEnvelope
    set?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    disconnect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    delete?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    update?: RoundAssignmentUpdateWithWhereUniqueWithoutJudgeInput | RoundAssignmentUpdateWithWhereUniqueWithoutJudgeInput[]
    updateMany?: RoundAssignmentUpdateManyWithWhereWithoutJudgeInput | RoundAssignmentUpdateManyWithWhereWithoutJudgeInput[]
    deleteMany?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
  }

  export type ScoreUpdateManyWithoutJudgeNestedInput = {
    create?: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput> | ScoreCreateWithoutJudgeInput[] | ScoreUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutJudgeInput | ScoreCreateOrConnectWithoutJudgeInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutJudgeInput | ScoreUpsertWithWhereUniqueWithoutJudgeInput[]
    createMany?: ScoreCreateManyJudgeInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutJudgeInput | ScoreUpdateWithWhereUniqueWithoutJudgeInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutJudgeInput | ScoreUpdateManyWithWhereWithoutJudgeInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type RoundAssignmentUncheckedUpdateManyWithoutJudgeNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutJudgeInput, RoundAssignmentUncheckedCreateWithoutJudgeInput> | RoundAssignmentCreateWithoutJudgeInput[] | RoundAssignmentUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutJudgeInput | RoundAssignmentCreateOrConnectWithoutJudgeInput[]
    upsert?: RoundAssignmentUpsertWithWhereUniqueWithoutJudgeInput | RoundAssignmentUpsertWithWhereUniqueWithoutJudgeInput[]
    createMany?: RoundAssignmentCreateManyJudgeInputEnvelope
    set?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    disconnect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    delete?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    update?: RoundAssignmentUpdateWithWhereUniqueWithoutJudgeInput | RoundAssignmentUpdateWithWhereUniqueWithoutJudgeInput[]
    updateMany?: RoundAssignmentUpdateManyWithWhereWithoutJudgeInput | RoundAssignmentUpdateManyWithWhereWithoutJudgeInput[]
    deleteMany?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
  }

  export type ScoreUncheckedUpdateManyWithoutJudgeNestedInput = {
    create?: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput> | ScoreCreateWithoutJudgeInput[] | ScoreUncheckedCreateWithoutJudgeInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutJudgeInput | ScoreCreateOrConnectWithoutJudgeInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutJudgeInput | ScoreUpsertWithWhereUniqueWithoutJudgeInput[]
    createMany?: ScoreCreateManyJudgeInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutJudgeInput | ScoreUpdateWithWhereUniqueWithoutJudgeInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutJudgeInput | ScoreUpdateManyWithWhereWithoutJudgeInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type RoundAssignmentCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoomInput, RoundAssignmentUncheckedCreateWithoutRoomInput> | RoundAssignmentCreateWithoutRoomInput[] | RoundAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoomInput | RoundAssignmentCreateOrConnectWithoutRoomInput[]
    createMany?: RoundAssignmentCreateManyRoomInputEnvelope
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
  }

  export type RoundAssignmentUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoomInput, RoundAssignmentUncheckedCreateWithoutRoomInput> | RoundAssignmentCreateWithoutRoomInput[] | RoundAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoomInput | RoundAssignmentCreateOrConnectWithoutRoomInput[]
    createMany?: RoundAssignmentCreateManyRoomInputEnvelope
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
  }

  export type RoundAssignmentUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoomInput, RoundAssignmentUncheckedCreateWithoutRoomInput> | RoundAssignmentCreateWithoutRoomInput[] | RoundAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoomInput | RoundAssignmentCreateOrConnectWithoutRoomInput[]
    upsert?: RoundAssignmentUpsertWithWhereUniqueWithoutRoomInput | RoundAssignmentUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoundAssignmentCreateManyRoomInputEnvelope
    set?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    disconnect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    delete?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    update?: RoundAssignmentUpdateWithWhereUniqueWithoutRoomInput | RoundAssignmentUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoundAssignmentUpdateManyWithWhereWithoutRoomInput | RoundAssignmentUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
  }

  export type RoundAssignmentUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoomInput, RoundAssignmentUncheckedCreateWithoutRoomInput> | RoundAssignmentCreateWithoutRoomInput[] | RoundAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoomInput | RoundAssignmentCreateOrConnectWithoutRoomInput[]
    upsert?: RoundAssignmentUpsertWithWhereUniqueWithoutRoomInput | RoundAssignmentUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoundAssignmentCreateManyRoomInputEnvelope
    set?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    disconnect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    delete?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    update?: RoundAssignmentUpdateWithWhereUniqueWithoutRoomInput | RoundAssignmentUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoundAssignmentUpdateManyWithWhereWithoutRoomInput | RoundAssignmentUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
  }

  export type RoundAssignmentCreateNestedManyWithoutRoundInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoundInput, RoundAssignmentUncheckedCreateWithoutRoundInput> | RoundAssignmentCreateWithoutRoundInput[] | RoundAssignmentUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoundInput | RoundAssignmentCreateOrConnectWithoutRoundInput[]
    createMany?: RoundAssignmentCreateManyRoundInputEnvelope
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
  }

  export type ScoreCreateNestedManyWithoutRoundInput = {
    create?: XOR<ScoreCreateWithoutRoundInput, ScoreUncheckedCreateWithoutRoundInput> | ScoreCreateWithoutRoundInput[] | ScoreUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutRoundInput | ScoreCreateOrConnectWithoutRoundInput[]
    createMany?: ScoreCreateManyRoundInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type RoundAssignmentUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoundInput, RoundAssignmentUncheckedCreateWithoutRoundInput> | RoundAssignmentCreateWithoutRoundInput[] | RoundAssignmentUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoundInput | RoundAssignmentCreateOrConnectWithoutRoundInput[]
    createMany?: RoundAssignmentCreateManyRoundInputEnvelope
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
  }

  export type ScoreUncheckedCreateNestedManyWithoutRoundInput = {
    create?: XOR<ScoreCreateWithoutRoundInput, ScoreUncheckedCreateWithoutRoundInput> | ScoreCreateWithoutRoundInput[] | ScoreUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutRoundInput | ScoreCreateOrConnectWithoutRoundInput[]
    createMany?: ScoreCreateManyRoundInputEnvelope
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
  }

  export type RoundAssignmentUpdateManyWithoutRoundNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoundInput, RoundAssignmentUncheckedCreateWithoutRoundInput> | RoundAssignmentCreateWithoutRoundInput[] | RoundAssignmentUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoundInput | RoundAssignmentCreateOrConnectWithoutRoundInput[]
    upsert?: RoundAssignmentUpsertWithWhereUniqueWithoutRoundInput | RoundAssignmentUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: RoundAssignmentCreateManyRoundInputEnvelope
    set?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    disconnect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    delete?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    update?: RoundAssignmentUpdateWithWhereUniqueWithoutRoundInput | RoundAssignmentUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: RoundAssignmentUpdateManyWithWhereWithoutRoundInput | RoundAssignmentUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
  }

  export type ScoreUpdateManyWithoutRoundNestedInput = {
    create?: XOR<ScoreCreateWithoutRoundInput, ScoreUncheckedCreateWithoutRoundInput> | ScoreCreateWithoutRoundInput[] | ScoreUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutRoundInput | ScoreCreateOrConnectWithoutRoundInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutRoundInput | ScoreUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: ScoreCreateManyRoundInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutRoundInput | ScoreUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutRoundInput | ScoreUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type RoundAssignmentUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutRoundInput, RoundAssignmentUncheckedCreateWithoutRoundInput> | RoundAssignmentCreateWithoutRoundInput[] | RoundAssignmentUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutRoundInput | RoundAssignmentCreateOrConnectWithoutRoundInput[]
    upsert?: RoundAssignmentUpsertWithWhereUniqueWithoutRoundInput | RoundAssignmentUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: RoundAssignmentCreateManyRoundInputEnvelope
    set?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    disconnect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    delete?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    connect?: RoundAssignmentWhereUniqueInput | RoundAssignmentWhereUniqueInput[]
    update?: RoundAssignmentUpdateWithWhereUniqueWithoutRoundInput | RoundAssignmentUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: RoundAssignmentUpdateManyWithWhereWithoutRoundInput | RoundAssignmentUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
  }

  export type ScoreUncheckedUpdateManyWithoutRoundNestedInput = {
    create?: XOR<ScoreCreateWithoutRoundInput, ScoreUncheckedCreateWithoutRoundInput> | ScoreCreateWithoutRoundInput[] | ScoreUncheckedCreateWithoutRoundInput[]
    connectOrCreate?: ScoreCreateOrConnectWithoutRoundInput | ScoreCreateOrConnectWithoutRoundInput[]
    upsert?: ScoreUpsertWithWhereUniqueWithoutRoundInput | ScoreUpsertWithWhereUniqueWithoutRoundInput[]
    createMany?: ScoreCreateManyRoundInputEnvelope
    set?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    disconnect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    delete?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    connect?: ScoreWhereUniqueInput | ScoreWhereUniqueInput[]
    update?: ScoreUpdateWithWhereUniqueWithoutRoundInput | ScoreUpdateWithWhereUniqueWithoutRoundInput[]
    updateMany?: ScoreUpdateManyWithWhereWithoutRoundInput | ScoreUpdateManyWithWhereWithoutRoundInput[]
    deleteMany?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
  }

  export type RoundCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<RoundCreateWithoutAssignmentsInput, RoundUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoundCreateOrConnectWithoutAssignmentsInput
    connect?: RoundWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAssignmentsInput
    connect?: RoomWhereUniqueInput
  }

  export type JudgeCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<JudgeCreateWithoutAssignmentsInput, JudgeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: JudgeCreateOrConnectWithoutAssignmentsInput
    connect?: JudgeWhereUniqueInput
  }

  export type MatchResultCreateNestedManyWithoutRoundAssignmentInput = {
    create?: XOR<MatchResultCreateWithoutRoundAssignmentInput, MatchResultUncheckedCreateWithoutRoundAssignmentInput> | MatchResultCreateWithoutRoundAssignmentInput[] | MatchResultUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutRoundAssignmentInput | MatchResultCreateOrConnectWithoutRoundAssignmentInput[]
    createMany?: MatchResultCreateManyRoundAssignmentInputEnvelope
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
  }

  export type TeamAssignmentCreateNestedManyWithoutRoundAssignmentInput = {
    create?: XOR<TeamAssignmentCreateWithoutRoundAssignmentInput, TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput> | TeamAssignmentCreateWithoutRoundAssignmentInput[] | TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput | TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput[]
    createMany?: TeamAssignmentCreateManyRoundAssignmentInputEnvelope
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
  }

  export type MatchResultUncheckedCreateNestedManyWithoutRoundAssignmentInput = {
    create?: XOR<MatchResultCreateWithoutRoundAssignmentInput, MatchResultUncheckedCreateWithoutRoundAssignmentInput> | MatchResultCreateWithoutRoundAssignmentInput[] | MatchResultUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutRoundAssignmentInput | MatchResultCreateOrConnectWithoutRoundAssignmentInput[]
    createMany?: MatchResultCreateManyRoundAssignmentInputEnvelope
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
  }

  export type TeamAssignmentUncheckedCreateNestedManyWithoutRoundAssignmentInput = {
    create?: XOR<TeamAssignmentCreateWithoutRoundAssignmentInput, TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput> | TeamAssignmentCreateWithoutRoundAssignmentInput[] | TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput | TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput[]
    createMany?: TeamAssignmentCreateManyRoundAssignmentInputEnvelope
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
  }

  export type RoundUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<RoundCreateWithoutAssignmentsInput, RoundUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoundCreateOrConnectWithoutAssignmentsInput
    upsert?: RoundUpsertWithoutAssignmentsInput
    connect?: RoundWhereUniqueInput
    update?: XOR<XOR<RoundUpdateToOneWithWhereWithoutAssignmentsInput, RoundUpdateWithoutAssignmentsInput>, RoundUncheckedUpdateWithoutAssignmentsInput>
  }

  export type RoomUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAssignmentsInput
    upsert?: RoomUpsertWithoutAssignmentsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutAssignmentsInput, RoomUpdateWithoutAssignmentsInput>, RoomUncheckedUpdateWithoutAssignmentsInput>
  }

  export type JudgeUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<JudgeCreateWithoutAssignmentsInput, JudgeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: JudgeCreateOrConnectWithoutAssignmentsInput
    upsert?: JudgeUpsertWithoutAssignmentsInput
    disconnect?: JudgeWhereInput | boolean
    delete?: JudgeWhereInput | boolean
    connect?: JudgeWhereUniqueInput
    update?: XOR<XOR<JudgeUpdateToOneWithWhereWithoutAssignmentsInput, JudgeUpdateWithoutAssignmentsInput>, JudgeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type MatchResultUpdateManyWithoutRoundAssignmentNestedInput = {
    create?: XOR<MatchResultCreateWithoutRoundAssignmentInput, MatchResultUncheckedCreateWithoutRoundAssignmentInput> | MatchResultCreateWithoutRoundAssignmentInput[] | MatchResultUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutRoundAssignmentInput | MatchResultCreateOrConnectWithoutRoundAssignmentInput[]
    upsert?: MatchResultUpsertWithWhereUniqueWithoutRoundAssignmentInput | MatchResultUpsertWithWhereUniqueWithoutRoundAssignmentInput[]
    createMany?: MatchResultCreateManyRoundAssignmentInputEnvelope
    set?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    disconnect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    delete?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    update?: MatchResultUpdateWithWhereUniqueWithoutRoundAssignmentInput | MatchResultUpdateWithWhereUniqueWithoutRoundAssignmentInput[]
    updateMany?: MatchResultUpdateManyWithWhereWithoutRoundAssignmentInput | MatchResultUpdateManyWithWhereWithoutRoundAssignmentInput[]
    deleteMany?: MatchResultScalarWhereInput | MatchResultScalarWhereInput[]
  }

  export type TeamAssignmentUpdateManyWithoutRoundAssignmentNestedInput = {
    create?: XOR<TeamAssignmentCreateWithoutRoundAssignmentInput, TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput> | TeamAssignmentCreateWithoutRoundAssignmentInput[] | TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput | TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput[]
    upsert?: TeamAssignmentUpsertWithWhereUniqueWithoutRoundAssignmentInput | TeamAssignmentUpsertWithWhereUniqueWithoutRoundAssignmentInput[]
    createMany?: TeamAssignmentCreateManyRoundAssignmentInputEnvelope
    set?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    disconnect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    delete?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    update?: TeamAssignmentUpdateWithWhereUniqueWithoutRoundAssignmentInput | TeamAssignmentUpdateWithWhereUniqueWithoutRoundAssignmentInput[]
    updateMany?: TeamAssignmentUpdateManyWithWhereWithoutRoundAssignmentInput | TeamAssignmentUpdateManyWithWhereWithoutRoundAssignmentInput[]
    deleteMany?: TeamAssignmentScalarWhereInput | TeamAssignmentScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MatchResultUncheckedUpdateManyWithoutRoundAssignmentNestedInput = {
    create?: XOR<MatchResultCreateWithoutRoundAssignmentInput, MatchResultUncheckedCreateWithoutRoundAssignmentInput> | MatchResultCreateWithoutRoundAssignmentInput[] | MatchResultUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: MatchResultCreateOrConnectWithoutRoundAssignmentInput | MatchResultCreateOrConnectWithoutRoundAssignmentInput[]
    upsert?: MatchResultUpsertWithWhereUniqueWithoutRoundAssignmentInput | MatchResultUpsertWithWhereUniqueWithoutRoundAssignmentInput[]
    createMany?: MatchResultCreateManyRoundAssignmentInputEnvelope
    set?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    disconnect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    delete?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    connect?: MatchResultWhereUniqueInput | MatchResultWhereUniqueInput[]
    update?: MatchResultUpdateWithWhereUniqueWithoutRoundAssignmentInput | MatchResultUpdateWithWhereUniqueWithoutRoundAssignmentInput[]
    updateMany?: MatchResultUpdateManyWithWhereWithoutRoundAssignmentInput | MatchResultUpdateManyWithWhereWithoutRoundAssignmentInput[]
    deleteMany?: MatchResultScalarWhereInput | MatchResultScalarWhereInput[]
  }

  export type TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentNestedInput = {
    create?: XOR<TeamAssignmentCreateWithoutRoundAssignmentInput, TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput> | TeamAssignmentCreateWithoutRoundAssignmentInput[] | TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput[]
    connectOrCreate?: TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput | TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput[]
    upsert?: TeamAssignmentUpsertWithWhereUniqueWithoutRoundAssignmentInput | TeamAssignmentUpsertWithWhereUniqueWithoutRoundAssignmentInput[]
    createMany?: TeamAssignmentCreateManyRoundAssignmentInputEnvelope
    set?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    disconnect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    delete?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    connect?: TeamAssignmentWhereUniqueInput | TeamAssignmentWhereUniqueInput[]
    update?: TeamAssignmentUpdateWithWhereUniqueWithoutRoundAssignmentInput | TeamAssignmentUpdateWithWhereUniqueWithoutRoundAssignmentInput[]
    updateMany?: TeamAssignmentUpdateManyWithWhereWithoutRoundAssignmentInput | TeamAssignmentUpdateManyWithWhereWithoutRoundAssignmentInput[]
    deleteMany?: TeamAssignmentScalarWhereInput | TeamAssignmentScalarWhereInput[]
  }

  export type JudgeCreateNestedOneWithoutScoresInput = {
    create?: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>
    connectOrCreate?: JudgeCreateOrConnectWithoutScoresInput
    connect?: JudgeWhereUniqueInput
  }

  export type RoundCreateNestedOneWithoutScoreInput = {
    create?: XOR<RoundCreateWithoutScoreInput, RoundUncheckedCreateWithoutScoreInput>
    connectOrCreate?: RoundCreateOrConnectWithoutScoreInput
    connect?: RoundWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutScoresInput = {
    create?: XOR<TeamCreateWithoutScoresInput, TeamUncheckedCreateWithoutScoresInput>
    connectOrCreate?: TeamCreateOrConnectWithoutScoresInput
    connect?: TeamWhereUniqueInput
  }

  export type ParticipantCreateNestedOneWithoutScoresInput = {
    create?: XOR<ParticipantCreateWithoutScoresInput, ParticipantUncheckedCreateWithoutScoresInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutScoresInput
    connect?: ParticipantWhereUniqueInput
  }

  export type EnumScoreTypeFieldUpdateOperationsInput = {
    set?: $Enums.ScoreType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type JudgeUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>
    connectOrCreate?: JudgeCreateOrConnectWithoutScoresInput
    upsert?: JudgeUpsertWithoutScoresInput
    connect?: JudgeWhereUniqueInput
    update?: XOR<XOR<JudgeUpdateToOneWithWhereWithoutScoresInput, JudgeUpdateWithoutScoresInput>, JudgeUncheckedUpdateWithoutScoresInput>
  }

  export type RoundUpdateOneRequiredWithoutScoreNestedInput = {
    create?: XOR<RoundCreateWithoutScoreInput, RoundUncheckedCreateWithoutScoreInput>
    connectOrCreate?: RoundCreateOrConnectWithoutScoreInput
    upsert?: RoundUpsertWithoutScoreInput
    connect?: RoundWhereUniqueInput
    update?: XOR<XOR<RoundUpdateToOneWithWhereWithoutScoreInput, RoundUpdateWithoutScoreInput>, RoundUncheckedUpdateWithoutScoreInput>
  }

  export type TeamUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<TeamCreateWithoutScoresInput, TeamUncheckedCreateWithoutScoresInput>
    connectOrCreate?: TeamCreateOrConnectWithoutScoresInput
    upsert?: TeamUpsertWithoutScoresInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutScoresInput, TeamUpdateWithoutScoresInput>, TeamUncheckedUpdateWithoutScoresInput>
  }

  export type ParticipantUpdateOneWithoutScoresNestedInput = {
    create?: XOR<ParticipantCreateWithoutScoresInput, ParticipantUncheckedCreateWithoutScoresInput>
    connectOrCreate?: ParticipantCreateOrConnectWithoutScoresInput
    upsert?: ParticipantUpsertWithoutScoresInput
    disconnect?: ParticipantWhereInput | boolean
    delete?: ParticipantWhereInput | boolean
    connect?: ParticipantWhereUniqueInput
    update?: XOR<XOR<ParticipantUpdateToOneWithWhereWithoutScoresInput, ParticipantUpdateWithoutScoresInput>, ParticipantUncheckedUpdateWithoutScoresInput>
  }

  export type RoundAssignmentCreateNestedOneWithoutMatchResultsInput = {
    create?: XOR<RoundAssignmentCreateWithoutMatchResultsInput, RoundAssignmentUncheckedCreateWithoutMatchResultsInput>
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutMatchResultsInput
    connect?: RoundAssignmentWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMatchResultsInput = {
    create?: XOR<TeamCreateWithoutMatchResultsInput, TeamUncheckedCreateWithoutMatchResultsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchResultsInput
    connect?: TeamWhereUniqueInput
  }

  export type RoundAssignmentUpdateOneRequiredWithoutMatchResultsNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutMatchResultsInput, RoundAssignmentUncheckedCreateWithoutMatchResultsInput>
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutMatchResultsInput
    upsert?: RoundAssignmentUpsertWithoutMatchResultsInput
    connect?: RoundAssignmentWhereUniqueInput
    update?: XOR<XOR<RoundAssignmentUpdateToOneWithWhereWithoutMatchResultsInput, RoundAssignmentUpdateWithoutMatchResultsInput>, RoundAssignmentUncheckedUpdateWithoutMatchResultsInput>
  }

  export type TeamUpdateOneRequiredWithoutMatchResultsNestedInput = {
    create?: XOR<TeamCreateWithoutMatchResultsInput, TeamUncheckedCreateWithoutMatchResultsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchResultsInput
    upsert?: TeamUpsertWithoutMatchResultsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMatchResultsInput, TeamUpdateWithoutMatchResultsInput>, TeamUncheckedUpdateWithoutMatchResultsInput>
  }

  export type TeamCreateNestedOneWithoutTeamAssignmentsInput = {
    create?: XOR<TeamCreateWithoutTeamAssignmentsInput, TeamUncheckedCreateWithoutTeamAssignmentsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamAssignmentsInput
    connect?: TeamWhereUniqueInput
  }

  export type RoundAssignmentCreateNestedOneWithoutTeamAssignmentsInput = {
    create?: XOR<RoundAssignmentCreateWithoutTeamAssignmentsInput, RoundAssignmentUncheckedCreateWithoutTeamAssignmentsInput>
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutTeamAssignmentsInput
    connect?: RoundAssignmentWhereUniqueInput
  }

  export type EnumDebatePositionFieldUpdateOperationsInput = {
    set?: $Enums.DebatePosition
  }

  export type TeamUpdateOneRequiredWithoutTeamAssignmentsNestedInput = {
    create?: XOR<TeamCreateWithoutTeamAssignmentsInput, TeamUncheckedCreateWithoutTeamAssignmentsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamAssignmentsInput
    upsert?: TeamUpsertWithoutTeamAssignmentsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTeamAssignmentsInput, TeamUpdateWithoutTeamAssignmentsInput>, TeamUncheckedUpdateWithoutTeamAssignmentsInput>
  }

  export type RoundAssignmentUpdateOneRequiredWithoutTeamAssignmentsNestedInput = {
    create?: XOR<RoundAssignmentCreateWithoutTeamAssignmentsInput, RoundAssignmentUncheckedCreateWithoutTeamAssignmentsInput>
    connectOrCreate?: RoundAssignmentCreateOrConnectWithoutTeamAssignmentsInput
    upsert?: RoundAssignmentUpsertWithoutTeamAssignmentsInput
    connect?: RoundAssignmentWhereUniqueInput
    update?: XOR<XOR<RoundAssignmentUpdateToOneWithWhereWithoutTeamAssignmentsInput, RoundAssignmentUpdateWithoutTeamAssignmentsInput>, RoundAssignmentUncheckedUpdateWithoutTeamAssignmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumScoreTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeFilter<$PrismaModel> | $Enums.ScoreType
  }

  export type NestedEnumScoreTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScoreType | EnumScoreTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScoreType[] | ListEnumScoreTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumScoreTypeWithAggregatesFilter<$PrismaModel> | $Enums.ScoreType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScoreTypeFilter<$PrismaModel>
    _max?: NestedEnumScoreTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDebatePositionFilter<$PrismaModel = never> = {
    equals?: $Enums.DebatePosition | EnumDebatePositionFieldRefInput<$PrismaModel>
    in?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    not?: NestedEnumDebatePositionFilter<$PrismaModel> | $Enums.DebatePosition
  }

  export type NestedEnumDebatePositionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DebatePosition | EnumDebatePositionFieldRefInput<$PrismaModel>
    in?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    notIn?: $Enums.DebatePosition[] | ListEnumDebatePositionFieldRefInput<$PrismaModel>
    not?: NestedEnumDebatePositionWithAggregatesFilter<$PrismaModel> | $Enums.DebatePosition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDebatePositionFilter<$PrismaModel>
    _max?: NestedEnumDebatePositionFilter<$PrismaModel>
  }

  export type ParticipantCreateWithoutTeamInput = {
    name: string
    email: string
    scores?: ScoreCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantUncheckedCreateWithoutTeamInput = {
    id?: number
    name: string
    email: string
    scores?: ScoreUncheckedCreateNestedManyWithoutParticipantInput
  }

  export type ParticipantCreateOrConnectWithoutTeamInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutTeamInput, ParticipantUncheckedCreateWithoutTeamInput>
  }

  export type ParticipantCreateManyTeamInputEnvelope = {
    data: ParticipantCreateManyTeamInput | ParticipantCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ScoreCreateWithoutTeamInput = {
    scoreType: $Enums.ScoreType
    value: number
    judge: JudgeCreateNestedOneWithoutScoresInput
    round: RoundCreateNestedOneWithoutScoreInput
    participant?: ParticipantCreateNestedOneWithoutScoresInput
  }

  export type ScoreUncheckedCreateWithoutTeamInput = {
    id?: number
    judgeId: number
    roundId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreCreateOrConnectWithoutTeamInput = {
    where: ScoreWhereUniqueInput
    create: XOR<ScoreCreateWithoutTeamInput, ScoreUncheckedCreateWithoutTeamInput>
  }

  export type ScoreCreateManyTeamInputEnvelope = {
    data: ScoreCreateManyTeamInput | ScoreCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type MatchResultCreateWithoutTeamInput = {
    rank: number
    points: number
    roundAssignment: RoundAssignmentCreateNestedOneWithoutMatchResultsInput
  }

  export type MatchResultUncheckedCreateWithoutTeamInput = {
    id?: number
    roundAssignmentId: number
    rank: number
    points: number
  }

  export type MatchResultCreateOrConnectWithoutTeamInput = {
    where: MatchResultWhereUniqueInput
    create: XOR<MatchResultCreateWithoutTeamInput, MatchResultUncheckedCreateWithoutTeamInput>
  }

  export type MatchResultCreateManyTeamInputEnvelope = {
    data: MatchResultCreateManyTeamInput | MatchResultCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamAssignmentCreateWithoutTeamInput = {
    position: $Enums.DebatePosition
    roundAssignment: RoundAssignmentCreateNestedOneWithoutTeamAssignmentsInput
  }

  export type TeamAssignmentUncheckedCreateWithoutTeamInput = {
    id?: number
    roundAssignmentId: number
    position: $Enums.DebatePosition
  }

  export type TeamAssignmentCreateOrConnectWithoutTeamInput = {
    where: TeamAssignmentWhereUniqueInput
    create: XOR<TeamAssignmentCreateWithoutTeamInput, TeamAssignmentUncheckedCreateWithoutTeamInput>
  }

  export type TeamAssignmentCreateManyTeamInputEnvelope = {
    data: TeamAssignmentCreateManyTeamInput | TeamAssignmentCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ParticipantUpsertWithWhereUniqueWithoutTeamInput = {
    where: ParticipantWhereUniqueInput
    update: XOR<ParticipantUpdateWithoutTeamInput, ParticipantUncheckedUpdateWithoutTeamInput>
    create: XOR<ParticipantCreateWithoutTeamInput, ParticipantUncheckedCreateWithoutTeamInput>
  }

  export type ParticipantUpdateWithWhereUniqueWithoutTeamInput = {
    where: ParticipantWhereUniqueInput
    data: XOR<ParticipantUpdateWithoutTeamInput, ParticipantUncheckedUpdateWithoutTeamInput>
  }

  export type ParticipantUpdateManyWithWhereWithoutTeamInput = {
    where: ParticipantScalarWhereInput
    data: XOR<ParticipantUpdateManyMutationInput, ParticipantUncheckedUpdateManyWithoutTeamInput>
  }

  export type ParticipantScalarWhereInput = {
    AND?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
    OR?: ParticipantScalarWhereInput[]
    NOT?: ParticipantScalarWhereInput | ParticipantScalarWhereInput[]
    id?: IntFilter<"Participant"> | number
    name?: StringFilter<"Participant"> | string
    email?: StringFilter<"Participant"> | string
    teamId?: IntFilter<"Participant"> | number
  }

  export type ScoreUpsertWithWhereUniqueWithoutTeamInput = {
    where: ScoreWhereUniqueInput
    update: XOR<ScoreUpdateWithoutTeamInput, ScoreUncheckedUpdateWithoutTeamInput>
    create: XOR<ScoreCreateWithoutTeamInput, ScoreUncheckedCreateWithoutTeamInput>
  }

  export type ScoreUpdateWithWhereUniqueWithoutTeamInput = {
    where: ScoreWhereUniqueInput
    data: XOR<ScoreUpdateWithoutTeamInput, ScoreUncheckedUpdateWithoutTeamInput>
  }

  export type ScoreUpdateManyWithWhereWithoutTeamInput = {
    where: ScoreScalarWhereInput
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutTeamInput>
  }

  export type ScoreScalarWhereInput = {
    AND?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
    OR?: ScoreScalarWhereInput[]
    NOT?: ScoreScalarWhereInput | ScoreScalarWhereInput[]
    id?: IntFilter<"Score"> | number
    judgeId?: IntFilter<"Score"> | number
    roundId?: IntFilter<"Score"> | number
    teamId?: IntFilter<"Score"> | number
    participantId?: IntNullableFilter<"Score"> | number | null
    scoreType?: EnumScoreTypeFilter<"Score"> | $Enums.ScoreType
    value?: FloatFilter<"Score"> | number
  }

  export type MatchResultUpsertWithWhereUniqueWithoutTeamInput = {
    where: MatchResultWhereUniqueInput
    update: XOR<MatchResultUpdateWithoutTeamInput, MatchResultUncheckedUpdateWithoutTeamInput>
    create: XOR<MatchResultCreateWithoutTeamInput, MatchResultUncheckedCreateWithoutTeamInput>
  }

  export type MatchResultUpdateWithWhereUniqueWithoutTeamInput = {
    where: MatchResultWhereUniqueInput
    data: XOR<MatchResultUpdateWithoutTeamInput, MatchResultUncheckedUpdateWithoutTeamInput>
  }

  export type MatchResultUpdateManyWithWhereWithoutTeamInput = {
    where: MatchResultScalarWhereInput
    data: XOR<MatchResultUpdateManyMutationInput, MatchResultUncheckedUpdateManyWithoutTeamInput>
  }

  export type MatchResultScalarWhereInput = {
    AND?: MatchResultScalarWhereInput | MatchResultScalarWhereInput[]
    OR?: MatchResultScalarWhereInput[]
    NOT?: MatchResultScalarWhereInput | MatchResultScalarWhereInput[]
    id?: IntFilter<"MatchResult"> | number
    roundAssignmentId?: IntFilter<"MatchResult"> | number
    teamId?: IntFilter<"MatchResult"> | number
    rank?: IntFilter<"MatchResult"> | number
    points?: IntFilter<"MatchResult"> | number
  }

  export type TeamAssignmentUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamAssignmentWhereUniqueInput
    update: XOR<TeamAssignmentUpdateWithoutTeamInput, TeamAssignmentUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamAssignmentCreateWithoutTeamInput, TeamAssignmentUncheckedCreateWithoutTeamInput>
  }

  export type TeamAssignmentUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamAssignmentWhereUniqueInput
    data: XOR<TeamAssignmentUpdateWithoutTeamInput, TeamAssignmentUncheckedUpdateWithoutTeamInput>
  }

  export type TeamAssignmentUpdateManyWithWhereWithoutTeamInput = {
    where: TeamAssignmentScalarWhereInput
    data: XOR<TeamAssignmentUpdateManyMutationInput, TeamAssignmentUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamAssignmentScalarWhereInput = {
    AND?: TeamAssignmentScalarWhereInput | TeamAssignmentScalarWhereInput[]
    OR?: TeamAssignmentScalarWhereInput[]
    NOT?: TeamAssignmentScalarWhereInput | TeamAssignmentScalarWhereInput[]
    id?: IntFilter<"TeamAssignment"> | number
    teamId?: IntFilter<"TeamAssignment"> | number
    roundAssignmentId?: IntFilter<"TeamAssignment"> | number
    position?: EnumDebatePositionFilter<"TeamAssignment"> | $Enums.DebatePosition
  }

  export type TeamCreateWithoutParticipantsInput = {
    name: string
    scores?: ScoreCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutParticipantsInput = {
    id?: number
    name: string
    scores?: ScoreUncheckedCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutParticipantsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutParticipantsInput, TeamUncheckedCreateWithoutParticipantsInput>
  }

  export type ScoreCreateWithoutParticipantInput = {
    scoreType: $Enums.ScoreType
    value: number
    judge: JudgeCreateNestedOneWithoutScoresInput
    round: RoundCreateNestedOneWithoutScoreInput
    team: TeamCreateNestedOneWithoutScoresInput
  }

  export type ScoreUncheckedCreateWithoutParticipantInput = {
    id?: number
    judgeId: number
    roundId: number
    teamId: number
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreCreateOrConnectWithoutParticipantInput = {
    where: ScoreWhereUniqueInput
    create: XOR<ScoreCreateWithoutParticipantInput, ScoreUncheckedCreateWithoutParticipantInput>
  }

  export type ScoreCreateManyParticipantInputEnvelope = {
    data: ScoreCreateManyParticipantInput | ScoreCreateManyParticipantInput[]
    skipDuplicates?: boolean
  }

  export type TeamUpsertWithoutParticipantsInput = {
    update: XOR<TeamUpdateWithoutParticipantsInput, TeamUncheckedUpdateWithoutParticipantsInput>
    create: XOR<TeamCreateWithoutParticipantsInput, TeamUncheckedCreateWithoutParticipantsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutParticipantsInput, TeamUncheckedUpdateWithoutParticipantsInput>
  }

  export type TeamUpdateWithoutParticipantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    scores?: ScoreUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutParticipantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    scores?: ScoreUncheckedUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUncheckedUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ScoreUpsertWithWhereUniqueWithoutParticipantInput = {
    where: ScoreWhereUniqueInput
    update: XOR<ScoreUpdateWithoutParticipantInput, ScoreUncheckedUpdateWithoutParticipantInput>
    create: XOR<ScoreCreateWithoutParticipantInput, ScoreUncheckedCreateWithoutParticipantInput>
  }

  export type ScoreUpdateWithWhereUniqueWithoutParticipantInput = {
    where: ScoreWhereUniqueInput
    data: XOR<ScoreUpdateWithoutParticipantInput, ScoreUncheckedUpdateWithoutParticipantInput>
  }

  export type ScoreUpdateManyWithWhereWithoutParticipantInput = {
    where: ScoreScalarWhereInput
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutParticipantInput>
  }

  export type RoundAssignmentCreateWithoutJudgeInput = {
    round: RoundCreateNestedOneWithoutAssignmentsInput
    room: RoomCreateNestedOneWithoutAssignmentsInput
    matchResults?: MatchResultCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUncheckedCreateWithoutJudgeInput = {
    id?: number
    roundId: number
    roomId: number
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentCreateOrConnectWithoutJudgeInput = {
    where: RoundAssignmentWhereUniqueInput
    create: XOR<RoundAssignmentCreateWithoutJudgeInput, RoundAssignmentUncheckedCreateWithoutJudgeInput>
  }

  export type RoundAssignmentCreateManyJudgeInputEnvelope = {
    data: RoundAssignmentCreateManyJudgeInput | RoundAssignmentCreateManyJudgeInput[]
    skipDuplicates?: boolean
  }

  export type ScoreCreateWithoutJudgeInput = {
    scoreType: $Enums.ScoreType
    value: number
    round: RoundCreateNestedOneWithoutScoreInput
    team: TeamCreateNestedOneWithoutScoresInput
    participant?: ParticipantCreateNestedOneWithoutScoresInput
  }

  export type ScoreUncheckedCreateWithoutJudgeInput = {
    id?: number
    roundId: number
    teamId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreCreateOrConnectWithoutJudgeInput = {
    where: ScoreWhereUniqueInput
    create: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
  }

  export type ScoreCreateManyJudgeInputEnvelope = {
    data: ScoreCreateManyJudgeInput | ScoreCreateManyJudgeInput[]
    skipDuplicates?: boolean
  }

  export type RoundAssignmentUpsertWithWhereUniqueWithoutJudgeInput = {
    where: RoundAssignmentWhereUniqueInput
    update: XOR<RoundAssignmentUpdateWithoutJudgeInput, RoundAssignmentUncheckedUpdateWithoutJudgeInput>
    create: XOR<RoundAssignmentCreateWithoutJudgeInput, RoundAssignmentUncheckedCreateWithoutJudgeInput>
  }

  export type RoundAssignmentUpdateWithWhereUniqueWithoutJudgeInput = {
    where: RoundAssignmentWhereUniqueInput
    data: XOR<RoundAssignmentUpdateWithoutJudgeInput, RoundAssignmentUncheckedUpdateWithoutJudgeInput>
  }

  export type RoundAssignmentUpdateManyWithWhereWithoutJudgeInput = {
    where: RoundAssignmentScalarWhereInput
    data: XOR<RoundAssignmentUpdateManyMutationInput, RoundAssignmentUncheckedUpdateManyWithoutJudgeInput>
  }

  export type RoundAssignmentScalarWhereInput = {
    AND?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
    OR?: RoundAssignmentScalarWhereInput[]
    NOT?: RoundAssignmentScalarWhereInput | RoundAssignmentScalarWhereInput[]
    id?: IntFilter<"RoundAssignment"> | number
    roundId?: IntFilter<"RoundAssignment"> | number
    roomId?: IntFilter<"RoundAssignment"> | number
    judgeId?: IntNullableFilter<"RoundAssignment"> | number | null
  }

  export type ScoreUpsertWithWhereUniqueWithoutJudgeInput = {
    where: ScoreWhereUniqueInput
    update: XOR<ScoreUpdateWithoutJudgeInput, ScoreUncheckedUpdateWithoutJudgeInput>
    create: XOR<ScoreCreateWithoutJudgeInput, ScoreUncheckedCreateWithoutJudgeInput>
  }

  export type ScoreUpdateWithWhereUniqueWithoutJudgeInput = {
    where: ScoreWhereUniqueInput
    data: XOR<ScoreUpdateWithoutJudgeInput, ScoreUncheckedUpdateWithoutJudgeInput>
  }

  export type ScoreUpdateManyWithWhereWithoutJudgeInput = {
    where: ScoreScalarWhereInput
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutJudgeInput>
  }

  export type RoundAssignmentCreateWithoutRoomInput = {
    round: RoundCreateNestedOneWithoutAssignmentsInput
    judge?: JudgeCreateNestedOneWithoutAssignmentsInput
    matchResults?: MatchResultCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUncheckedCreateWithoutRoomInput = {
    id?: number
    roundId: number
    judgeId?: number | null
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentCreateOrConnectWithoutRoomInput = {
    where: RoundAssignmentWhereUniqueInput
    create: XOR<RoundAssignmentCreateWithoutRoomInput, RoundAssignmentUncheckedCreateWithoutRoomInput>
  }

  export type RoundAssignmentCreateManyRoomInputEnvelope = {
    data: RoundAssignmentCreateManyRoomInput | RoundAssignmentCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoundAssignmentUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoundAssignmentWhereUniqueInput
    update: XOR<RoundAssignmentUpdateWithoutRoomInput, RoundAssignmentUncheckedUpdateWithoutRoomInput>
    create: XOR<RoundAssignmentCreateWithoutRoomInput, RoundAssignmentUncheckedCreateWithoutRoomInput>
  }

  export type RoundAssignmentUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoundAssignmentWhereUniqueInput
    data: XOR<RoundAssignmentUpdateWithoutRoomInput, RoundAssignmentUncheckedUpdateWithoutRoomInput>
  }

  export type RoundAssignmentUpdateManyWithWhereWithoutRoomInput = {
    where: RoundAssignmentScalarWhereInput
    data: XOR<RoundAssignmentUpdateManyMutationInput, RoundAssignmentUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoundAssignmentCreateWithoutRoundInput = {
    room: RoomCreateNestedOneWithoutAssignmentsInput
    judge?: JudgeCreateNestedOneWithoutAssignmentsInput
    matchResults?: MatchResultCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUncheckedCreateWithoutRoundInput = {
    id?: number
    roomId: number
    judgeId?: number | null
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutRoundAssignmentInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentCreateOrConnectWithoutRoundInput = {
    where: RoundAssignmentWhereUniqueInput
    create: XOR<RoundAssignmentCreateWithoutRoundInput, RoundAssignmentUncheckedCreateWithoutRoundInput>
  }

  export type RoundAssignmentCreateManyRoundInputEnvelope = {
    data: RoundAssignmentCreateManyRoundInput | RoundAssignmentCreateManyRoundInput[]
    skipDuplicates?: boolean
  }

  export type ScoreCreateWithoutRoundInput = {
    scoreType: $Enums.ScoreType
    value: number
    judge: JudgeCreateNestedOneWithoutScoresInput
    team: TeamCreateNestedOneWithoutScoresInput
    participant?: ParticipantCreateNestedOneWithoutScoresInput
  }

  export type ScoreUncheckedCreateWithoutRoundInput = {
    id?: number
    judgeId: number
    teamId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreCreateOrConnectWithoutRoundInput = {
    where: ScoreWhereUniqueInput
    create: XOR<ScoreCreateWithoutRoundInput, ScoreUncheckedCreateWithoutRoundInput>
  }

  export type ScoreCreateManyRoundInputEnvelope = {
    data: ScoreCreateManyRoundInput | ScoreCreateManyRoundInput[]
    skipDuplicates?: boolean
  }

  export type RoundAssignmentUpsertWithWhereUniqueWithoutRoundInput = {
    where: RoundAssignmentWhereUniqueInput
    update: XOR<RoundAssignmentUpdateWithoutRoundInput, RoundAssignmentUncheckedUpdateWithoutRoundInput>
    create: XOR<RoundAssignmentCreateWithoutRoundInput, RoundAssignmentUncheckedCreateWithoutRoundInput>
  }

  export type RoundAssignmentUpdateWithWhereUniqueWithoutRoundInput = {
    where: RoundAssignmentWhereUniqueInput
    data: XOR<RoundAssignmentUpdateWithoutRoundInput, RoundAssignmentUncheckedUpdateWithoutRoundInput>
  }

  export type RoundAssignmentUpdateManyWithWhereWithoutRoundInput = {
    where: RoundAssignmentScalarWhereInput
    data: XOR<RoundAssignmentUpdateManyMutationInput, RoundAssignmentUncheckedUpdateManyWithoutRoundInput>
  }

  export type ScoreUpsertWithWhereUniqueWithoutRoundInput = {
    where: ScoreWhereUniqueInput
    update: XOR<ScoreUpdateWithoutRoundInput, ScoreUncheckedUpdateWithoutRoundInput>
    create: XOR<ScoreCreateWithoutRoundInput, ScoreUncheckedCreateWithoutRoundInput>
  }

  export type ScoreUpdateWithWhereUniqueWithoutRoundInput = {
    where: ScoreWhereUniqueInput
    data: XOR<ScoreUpdateWithoutRoundInput, ScoreUncheckedUpdateWithoutRoundInput>
  }

  export type ScoreUpdateManyWithWhereWithoutRoundInput = {
    where: ScoreScalarWhereInput
    data: XOR<ScoreUpdateManyMutationInput, ScoreUncheckedUpdateManyWithoutRoundInput>
  }

  export type RoundCreateWithoutAssignmentsInput = {
    name: string
    number: number
    Score?: ScoreCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
    number: number
    Score?: ScoreUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutAssignmentsInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutAssignmentsInput, RoundUncheckedCreateWithoutAssignmentsInput>
  }

  export type RoomCreateWithoutAssignmentsInput = {
    name: string
  }

  export type RoomUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
  }

  export type RoomCreateOrConnectWithoutAssignmentsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
  }

  export type JudgeCreateWithoutAssignmentsInput = {
    name: string
    email: string
    password: string
    scores?: ScoreCreateNestedManyWithoutJudgeInput
  }

  export type JudgeUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
    email: string
    password: string
    scores?: ScoreUncheckedCreateNestedManyWithoutJudgeInput
  }

  export type JudgeCreateOrConnectWithoutAssignmentsInput = {
    where: JudgeWhereUniqueInput
    create: XOR<JudgeCreateWithoutAssignmentsInput, JudgeUncheckedCreateWithoutAssignmentsInput>
  }

  export type MatchResultCreateWithoutRoundAssignmentInput = {
    rank: number
    points: number
    team: TeamCreateNestedOneWithoutMatchResultsInput
  }

  export type MatchResultUncheckedCreateWithoutRoundAssignmentInput = {
    id?: number
    teamId: number
    rank: number
    points: number
  }

  export type MatchResultCreateOrConnectWithoutRoundAssignmentInput = {
    where: MatchResultWhereUniqueInput
    create: XOR<MatchResultCreateWithoutRoundAssignmentInput, MatchResultUncheckedCreateWithoutRoundAssignmentInput>
  }

  export type MatchResultCreateManyRoundAssignmentInputEnvelope = {
    data: MatchResultCreateManyRoundAssignmentInput | MatchResultCreateManyRoundAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type TeamAssignmentCreateWithoutRoundAssignmentInput = {
    position: $Enums.DebatePosition
    team: TeamCreateNestedOneWithoutTeamAssignmentsInput
  }

  export type TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput = {
    id?: number
    teamId: number
    position: $Enums.DebatePosition
  }

  export type TeamAssignmentCreateOrConnectWithoutRoundAssignmentInput = {
    where: TeamAssignmentWhereUniqueInput
    create: XOR<TeamAssignmentCreateWithoutRoundAssignmentInput, TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput>
  }

  export type TeamAssignmentCreateManyRoundAssignmentInputEnvelope = {
    data: TeamAssignmentCreateManyRoundAssignmentInput | TeamAssignmentCreateManyRoundAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type RoundUpsertWithoutAssignmentsInput = {
    update: XOR<RoundUpdateWithoutAssignmentsInput, RoundUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<RoundCreateWithoutAssignmentsInput, RoundUncheckedCreateWithoutAssignmentsInput>
    where?: RoundWhereInput
  }

  export type RoundUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: RoundWhereInput
    data: XOR<RoundUpdateWithoutAssignmentsInput, RoundUncheckedUpdateWithoutAssignmentsInput>
  }

  export type RoundUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    Score?: ScoreUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    Score?: ScoreUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type RoomUpsertWithoutAssignmentsInput = {
    update: XOR<RoomUpdateWithoutAssignmentsInput, RoomUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutAssignmentsInput, RoomUncheckedUpdateWithoutAssignmentsInput>
  }

  export type RoomUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoomUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type JudgeUpsertWithoutAssignmentsInput = {
    update: XOR<JudgeUpdateWithoutAssignmentsInput, JudgeUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<JudgeCreateWithoutAssignmentsInput, JudgeUncheckedCreateWithoutAssignmentsInput>
    where?: JudgeWhereInput
  }

  export type JudgeUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: JudgeWhereInput
    data: XOR<JudgeUpdateWithoutAssignmentsInput, JudgeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type JudgeUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    scores?: ScoreUpdateManyWithoutJudgeNestedInput
  }

  export type JudgeUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    scores?: ScoreUncheckedUpdateManyWithoutJudgeNestedInput
  }

  export type MatchResultUpsertWithWhereUniqueWithoutRoundAssignmentInput = {
    where: MatchResultWhereUniqueInput
    update: XOR<MatchResultUpdateWithoutRoundAssignmentInput, MatchResultUncheckedUpdateWithoutRoundAssignmentInput>
    create: XOR<MatchResultCreateWithoutRoundAssignmentInput, MatchResultUncheckedCreateWithoutRoundAssignmentInput>
  }

  export type MatchResultUpdateWithWhereUniqueWithoutRoundAssignmentInput = {
    where: MatchResultWhereUniqueInput
    data: XOR<MatchResultUpdateWithoutRoundAssignmentInput, MatchResultUncheckedUpdateWithoutRoundAssignmentInput>
  }

  export type MatchResultUpdateManyWithWhereWithoutRoundAssignmentInput = {
    where: MatchResultScalarWhereInput
    data: XOR<MatchResultUpdateManyMutationInput, MatchResultUncheckedUpdateManyWithoutRoundAssignmentInput>
  }

  export type TeamAssignmentUpsertWithWhereUniqueWithoutRoundAssignmentInput = {
    where: TeamAssignmentWhereUniqueInput
    update: XOR<TeamAssignmentUpdateWithoutRoundAssignmentInput, TeamAssignmentUncheckedUpdateWithoutRoundAssignmentInput>
    create: XOR<TeamAssignmentCreateWithoutRoundAssignmentInput, TeamAssignmentUncheckedCreateWithoutRoundAssignmentInput>
  }

  export type TeamAssignmentUpdateWithWhereUniqueWithoutRoundAssignmentInput = {
    where: TeamAssignmentWhereUniqueInput
    data: XOR<TeamAssignmentUpdateWithoutRoundAssignmentInput, TeamAssignmentUncheckedUpdateWithoutRoundAssignmentInput>
  }

  export type TeamAssignmentUpdateManyWithWhereWithoutRoundAssignmentInput = {
    where: TeamAssignmentScalarWhereInput
    data: XOR<TeamAssignmentUpdateManyMutationInput, TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentInput>
  }

  export type JudgeCreateWithoutScoresInput = {
    name: string
    email: string
    password: string
    assignments?: RoundAssignmentCreateNestedManyWithoutJudgeInput
  }

  export type JudgeUncheckedCreateWithoutScoresInput = {
    id?: number
    name: string
    email: string
    password: string
    assignments?: RoundAssignmentUncheckedCreateNestedManyWithoutJudgeInput
  }

  export type JudgeCreateOrConnectWithoutScoresInput = {
    where: JudgeWhereUniqueInput
    create: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>
  }

  export type RoundCreateWithoutScoreInput = {
    name: string
    number: number
    assignments?: RoundAssignmentCreateNestedManyWithoutRoundInput
  }

  export type RoundUncheckedCreateWithoutScoreInput = {
    id?: number
    name: string
    number: number
    assignments?: RoundAssignmentUncheckedCreateNestedManyWithoutRoundInput
  }

  export type RoundCreateOrConnectWithoutScoreInput = {
    where: RoundWhereUniqueInput
    create: XOR<RoundCreateWithoutScoreInput, RoundUncheckedCreateWithoutScoreInput>
  }

  export type TeamCreateWithoutScoresInput = {
    name: string
    participants?: ParticipantCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutScoresInput = {
    id?: number
    name: string
    participants?: ParticipantUncheckedCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutScoresInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutScoresInput, TeamUncheckedCreateWithoutScoresInput>
  }

  export type ParticipantCreateWithoutScoresInput = {
    name: string
    email: string
    team: TeamCreateNestedOneWithoutParticipantsInput
  }

  export type ParticipantUncheckedCreateWithoutScoresInput = {
    id?: number
    name: string
    email: string
    teamId: number
  }

  export type ParticipantCreateOrConnectWithoutScoresInput = {
    where: ParticipantWhereUniqueInput
    create: XOR<ParticipantCreateWithoutScoresInput, ParticipantUncheckedCreateWithoutScoresInput>
  }

  export type JudgeUpsertWithoutScoresInput = {
    update: XOR<JudgeUpdateWithoutScoresInput, JudgeUncheckedUpdateWithoutScoresInput>
    create: XOR<JudgeCreateWithoutScoresInput, JudgeUncheckedCreateWithoutScoresInput>
    where?: JudgeWhereInput
  }

  export type JudgeUpdateToOneWithWhereWithoutScoresInput = {
    where?: JudgeWhereInput
    data: XOR<JudgeUpdateWithoutScoresInput, JudgeUncheckedUpdateWithoutScoresInput>
  }

  export type JudgeUpdateWithoutScoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    assignments?: RoundAssignmentUpdateManyWithoutJudgeNestedInput
  }

  export type JudgeUncheckedUpdateWithoutScoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    assignments?: RoundAssignmentUncheckedUpdateManyWithoutJudgeNestedInput
  }

  export type RoundUpsertWithoutScoreInput = {
    update: XOR<RoundUpdateWithoutScoreInput, RoundUncheckedUpdateWithoutScoreInput>
    create: XOR<RoundCreateWithoutScoreInput, RoundUncheckedCreateWithoutScoreInput>
    where?: RoundWhereInput
  }

  export type RoundUpdateToOneWithWhereWithoutScoreInput = {
    where?: RoundWhereInput
    data: XOR<RoundUpdateWithoutScoreInput, RoundUncheckedUpdateWithoutScoreInput>
  }

  export type RoundUpdateWithoutScoreInput = {
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    assignments?: RoundAssignmentUpdateManyWithoutRoundNestedInput
  }

  export type RoundUncheckedUpdateWithoutScoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    assignments?: RoundAssignmentUncheckedUpdateManyWithoutRoundNestedInput
  }

  export type TeamUpsertWithoutScoresInput = {
    update: XOR<TeamUpdateWithoutScoresInput, TeamUncheckedUpdateWithoutScoresInput>
    create: XOR<TeamCreateWithoutScoresInput, TeamUncheckedCreateWithoutScoresInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutScoresInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutScoresInput, TeamUncheckedUpdateWithoutScoresInput>
  }

  export type TeamUpdateWithoutScoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutScoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUncheckedUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUncheckedUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type ParticipantUpsertWithoutScoresInput = {
    update: XOR<ParticipantUpdateWithoutScoresInput, ParticipantUncheckedUpdateWithoutScoresInput>
    create: XOR<ParticipantCreateWithoutScoresInput, ParticipantUncheckedCreateWithoutScoresInput>
    where?: ParticipantWhereInput
  }

  export type ParticipantUpdateToOneWithWhereWithoutScoresInput = {
    where?: ParticipantWhereInput
    data: XOR<ParticipantUpdateWithoutScoresInput, ParticipantUncheckedUpdateWithoutScoresInput>
  }

  export type ParticipantUpdateWithoutScoresInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutScoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type RoundAssignmentCreateWithoutMatchResultsInput = {
    round: RoundCreateNestedOneWithoutAssignmentsInput
    room: RoomCreateNestedOneWithoutAssignmentsInput
    judge?: JudgeCreateNestedOneWithoutAssignmentsInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUncheckedCreateWithoutMatchResultsInput = {
    id?: number
    roundId: number
    roomId: number
    judgeId?: number | null
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentCreateOrConnectWithoutMatchResultsInput = {
    where: RoundAssignmentWhereUniqueInput
    create: XOR<RoundAssignmentCreateWithoutMatchResultsInput, RoundAssignmentUncheckedCreateWithoutMatchResultsInput>
  }

  export type TeamCreateWithoutMatchResultsInput = {
    name: string
    participants?: ParticipantCreateNestedManyWithoutTeamInput
    scores?: ScoreCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMatchResultsInput = {
    id?: number
    name: string
    participants?: ParticipantUncheckedCreateNestedManyWithoutTeamInput
    scores?: ScoreUncheckedCreateNestedManyWithoutTeamInput
    teamAssignments?: TeamAssignmentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMatchResultsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMatchResultsInput, TeamUncheckedCreateWithoutMatchResultsInput>
  }

  export type RoundAssignmentUpsertWithoutMatchResultsInput = {
    update: XOR<RoundAssignmentUpdateWithoutMatchResultsInput, RoundAssignmentUncheckedUpdateWithoutMatchResultsInput>
    create: XOR<RoundAssignmentCreateWithoutMatchResultsInput, RoundAssignmentUncheckedCreateWithoutMatchResultsInput>
    where?: RoundAssignmentWhereInput
  }

  export type RoundAssignmentUpdateToOneWithWhereWithoutMatchResultsInput = {
    where?: RoundAssignmentWhereInput
    data: XOR<RoundAssignmentUpdateWithoutMatchResultsInput, RoundAssignmentUncheckedUpdateWithoutMatchResultsInput>
  }

  export type RoundAssignmentUpdateWithoutMatchResultsInput = {
    round?: RoundUpdateOneRequiredWithoutAssignmentsNestedInput
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
    judge?: JudgeUpdateOneWithoutAssignmentsNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateWithoutMatchResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type TeamUpsertWithoutMatchResultsInput = {
    update: XOR<TeamUpdateWithoutMatchResultsInput, TeamUncheckedUpdateWithoutMatchResultsInput>
    create: XOR<TeamCreateWithoutMatchResultsInput, TeamUncheckedCreateWithoutMatchResultsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMatchResultsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMatchResultsInput, TeamUncheckedUpdateWithoutMatchResultsInput>
  }

  export type TeamUpdateWithoutMatchResultsInput = {
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUpdateManyWithoutTeamNestedInput
    scores?: ScoreUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMatchResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUncheckedUpdateManyWithoutTeamNestedInput
    scores?: ScoreUncheckedUpdateManyWithoutTeamNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutTeamAssignmentsInput = {
    name: string
    participants?: ParticipantCreateNestedManyWithoutTeamInput
    scores?: ScoreCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamAssignmentsInput = {
    id?: number
    name: string
    participants?: ParticipantUncheckedCreateNestedManyWithoutTeamInput
    scores?: ScoreUncheckedCreateNestedManyWithoutTeamInput
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamAssignmentsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamAssignmentsInput, TeamUncheckedCreateWithoutTeamAssignmentsInput>
  }

  export type RoundAssignmentCreateWithoutTeamAssignmentsInput = {
    round: RoundCreateNestedOneWithoutAssignmentsInput
    room: RoomCreateNestedOneWithoutAssignmentsInput
    judge?: JudgeCreateNestedOneWithoutAssignmentsInput
    matchResults?: MatchResultCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentUncheckedCreateWithoutTeamAssignmentsInput = {
    id?: number
    roundId: number
    roomId: number
    judgeId?: number | null
    matchResults?: MatchResultUncheckedCreateNestedManyWithoutRoundAssignmentInput
  }

  export type RoundAssignmentCreateOrConnectWithoutTeamAssignmentsInput = {
    where: RoundAssignmentWhereUniqueInput
    create: XOR<RoundAssignmentCreateWithoutTeamAssignmentsInput, RoundAssignmentUncheckedCreateWithoutTeamAssignmentsInput>
  }

  export type TeamUpsertWithoutTeamAssignmentsInput = {
    update: XOR<TeamUpdateWithoutTeamAssignmentsInput, TeamUncheckedUpdateWithoutTeamAssignmentsInput>
    create: XOR<TeamCreateWithoutTeamAssignmentsInput, TeamUncheckedCreateWithoutTeamAssignmentsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTeamAssignmentsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTeamAssignmentsInput, TeamUncheckedUpdateWithoutTeamAssignmentsInput>
  }

  export type TeamUpdateWithoutTeamAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUpdateManyWithoutTeamNestedInput
    scores?: ScoreUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    participants?: ParticipantUncheckedUpdateManyWithoutTeamNestedInput
    scores?: ScoreUncheckedUpdateManyWithoutTeamNestedInput
    matchResults?: MatchResultUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type RoundAssignmentUpsertWithoutTeamAssignmentsInput = {
    update: XOR<RoundAssignmentUpdateWithoutTeamAssignmentsInput, RoundAssignmentUncheckedUpdateWithoutTeamAssignmentsInput>
    create: XOR<RoundAssignmentCreateWithoutTeamAssignmentsInput, RoundAssignmentUncheckedCreateWithoutTeamAssignmentsInput>
    where?: RoundAssignmentWhereInput
  }

  export type RoundAssignmentUpdateToOneWithWhereWithoutTeamAssignmentsInput = {
    where?: RoundAssignmentWhereInput
    data: XOR<RoundAssignmentUpdateWithoutTeamAssignmentsInput, RoundAssignmentUncheckedUpdateWithoutTeamAssignmentsInput>
  }

  export type RoundAssignmentUpdateWithoutTeamAssignmentsInput = {
    round?: RoundUpdateOneRequiredWithoutAssignmentsNestedInput
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
    judge?: JudgeUpdateOneWithoutAssignmentsNestedInput
    matchResults?: MatchResultUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateWithoutTeamAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
    matchResults?: MatchResultUncheckedUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type ParticipantCreateManyTeamInput = {
    id?: number
    name: string
    email: string
  }

  export type ScoreCreateManyTeamInput = {
    id?: number
    judgeId: number
    roundId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type MatchResultCreateManyTeamInput = {
    id?: number
    roundAssignmentId: number
    rank: number
    points: number
  }

  export type TeamAssignmentCreateManyTeamInput = {
    id?: number
    roundAssignmentId: number
    position: $Enums.DebatePosition
  }

  export type ParticipantUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    scores?: ScoreUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    scores?: ScoreUncheckedUpdateManyWithoutParticipantNestedInput
  }

  export type ParticipantUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type ScoreUpdateWithoutTeamInput = {
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput
    round?: RoundUpdateOneRequiredWithoutScoreNestedInput
    participant?: ParticipantUpdateOneWithoutScoresNestedInput
  }

  export type ScoreUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type ScoreUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type MatchResultUpdateWithoutTeamInput = {
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    roundAssignment?: RoundAssignmentUpdateOneRequiredWithoutMatchResultsNestedInput
  }

  export type MatchResultUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type MatchResultUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TeamAssignmentUpdateWithoutTeamInput = {
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
    roundAssignment?: RoundAssignmentUpdateOneRequiredWithoutTeamAssignmentsNestedInput
  }

  export type TeamAssignmentUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }

  export type TeamAssignmentUncheckedUpdateManyWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundAssignmentId?: IntFieldUpdateOperationsInput | number
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }

  export type ScoreCreateManyParticipantInput = {
    id?: number
    judgeId: number
    roundId: number
    teamId: number
    scoreType: $Enums.ScoreType
    value: number
  }

  export type ScoreUpdateWithoutParticipantInput = {
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput
    round?: RoundUpdateOneRequiredWithoutScoreNestedInput
    team?: TeamUpdateOneRequiredWithoutScoresNestedInput
  }

  export type ScoreUncheckedUpdateWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type ScoreUncheckedUpdateManyWithoutParticipantInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type RoundAssignmentCreateManyJudgeInput = {
    id?: number
    roundId: number
    roomId: number
  }

  export type ScoreCreateManyJudgeInput = {
    id?: number
    roundId: number
    teamId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type RoundAssignmentUpdateWithoutJudgeInput = {
    round?: RoundUpdateOneRequiredWithoutAssignmentsNestedInput
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
    matchResults?: MatchResultUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateWithoutJudgeInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    matchResults?: MatchResultUncheckedUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateManyWithoutJudgeInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
  }

  export type ScoreUpdateWithoutJudgeInput = {
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
    round?: RoundUpdateOneRequiredWithoutScoreNestedInput
    team?: TeamUpdateOneRequiredWithoutScoresNestedInput
    participant?: ParticipantUpdateOneWithoutScoresNestedInput
  }

  export type ScoreUncheckedUpdateWithoutJudgeInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type ScoreUncheckedUpdateManyWithoutJudgeInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type RoundAssignmentCreateManyRoomInput = {
    id?: number
    roundId: number
    judgeId?: number | null
  }

  export type RoundAssignmentUpdateWithoutRoomInput = {
    round?: RoundUpdateOneRequiredWithoutAssignmentsNestedInput
    judge?: JudgeUpdateOneWithoutAssignmentsNestedInput
    matchResults?: MatchResultUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
    matchResults?: MatchResultUncheckedUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    roundId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoundAssignmentCreateManyRoundInput = {
    id?: number
    roomId: number
    judgeId?: number | null
  }

  export type ScoreCreateManyRoundInput = {
    id?: number
    judgeId: number
    teamId: number
    participantId?: number | null
    scoreType: $Enums.ScoreType
    value: number
  }

  export type RoundAssignmentUpdateWithoutRoundInput = {
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
    judge?: JudgeUpdateOneWithoutAssignmentsNestedInput
    matchResults?: MatchResultUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
    matchResults?: MatchResultUncheckedUpdateManyWithoutRoundAssignmentNestedInput
    teamAssignments?: TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentNestedInput
  }

  export type RoundAssignmentUncheckedUpdateManyWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    judgeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ScoreUpdateWithoutRoundInput = {
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
    judge?: JudgeUpdateOneRequiredWithoutScoresNestedInput
    team?: TeamUpdateOneRequiredWithoutScoresNestedInput
    participant?: ParticipantUpdateOneWithoutScoresNestedInput
  }

  export type ScoreUncheckedUpdateWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type ScoreUncheckedUpdateManyWithoutRoundInput = {
    id?: IntFieldUpdateOperationsInput | number
    judgeId?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    participantId?: NullableIntFieldUpdateOperationsInput | number | null
    scoreType?: EnumScoreTypeFieldUpdateOperationsInput | $Enums.ScoreType
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type MatchResultCreateManyRoundAssignmentInput = {
    id?: number
    teamId: number
    rank: number
    points: number
  }

  export type TeamAssignmentCreateManyRoundAssignmentInput = {
    id?: number
    teamId: number
    position: $Enums.DebatePosition
  }

  export type MatchResultUpdateWithoutRoundAssignmentInput = {
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutMatchResultsNestedInput
  }

  export type MatchResultUncheckedUpdateWithoutRoundAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type MatchResultUncheckedUpdateManyWithoutRoundAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
  }

  export type TeamAssignmentUpdateWithoutRoundAssignmentInput = {
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
    team?: TeamUpdateOneRequiredWithoutTeamAssignmentsNestedInput
  }

  export type TeamAssignmentUncheckedUpdateWithoutRoundAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }

  export type TeamAssignmentUncheckedUpdateManyWithoutRoundAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    teamId?: IntFieldUpdateOperationsInput | number
    position?: EnumDebatePositionFieldUpdateOperationsInput | $Enums.DebatePosition
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}